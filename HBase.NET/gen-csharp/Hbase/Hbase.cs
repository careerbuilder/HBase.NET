/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.IO;
using Thrift;
using Thrift.Collections;
using System.Runtime.Serialization;
using Thrift.Protocol;
using Thrift.Transport;

namespace Hbase
{
  public partial class Hbase {
    public interface ISync {
      /// <summary>
      /// Brings a table on-line (enables it)
      /// </summary>
      /// <param name="tableName">name of the table</param>
      void enableTable(byte[] tableName);
      /// <summary>
      /// Disables a table (takes it off-line) If it is being served, the master
      /// will tell the servers to stop serving it.
      /// </summary>
      /// <param name="tableName">name of the table</param>
      void disableTable(byte[] tableName);
      /// <summary>
      /// @return true if table is on-line
      /// </summary>
      /// <param name="tableName">name of the table to check</param>
      bool isTableEnabled(byte[] tableName);
      void compact(byte[] tableNameOrRegionName);
      void majorCompact(byte[] tableNameOrRegionName);
      /// <summary>
      /// List all the userspace tables.
      /// 
      /// @return returns a list of names
      /// </summary>
      List<byte[]> getTableNames();
      /// <summary>
      /// List all the column families assoicated with a table.
      /// 
      /// @return list of column family descriptors
      /// </summary>
      /// <param name="tableName">table name</param>
      Dictionary<byte[], ColumnDescriptor> getColumnDescriptors(byte[] tableName);
      /// <summary>
      /// List the regions associated with a table.
      /// 
      /// @return list of region descriptors
      /// </summary>
      /// <param name="tableName">table name</param>
      List<TRegionInfo> getTableRegions(byte[] tableName);
      /// <summary>
      /// Create a table with the specified column families.  The name
      /// field for each ColumnDescriptor must be set and must end in a
      /// colon (:). All other fields are optional and will get default
      /// values if not explicitly specified.
      /// 
      /// @throws IllegalArgument if an input parameter is invalid
      /// 
      /// @throws AlreadyExists if the table name already exists
      /// </summary>
      /// <param name="tableName">name of table to create</param>
      /// <param name="columnFamilies">list of column family descriptors</param>
      void createTable(byte[] tableName, List<ColumnDescriptor> columnFamilies);
      /// <summary>
      /// Deletes a table
      /// 
      /// @throws IOError if table doesn't exist on server or there was some other
      /// problem
      /// </summary>
      /// <param name="tableName">name of table to delete</param>
      void deleteTable(byte[] tableName);
      /// <summary>
      /// Get a single TCell for the specified table, row, and column at the
      /// latest timestamp. Returns an empty list if no such value exists.
      /// 
      /// @return value for specified row/column
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="row">row key</param>
      /// <param name="column">column name</param>
      /// <param name="attributes">Get attributes</param>
      List<TCell> @get(byte[] tableName, byte[] row, byte[] column, Dictionary<byte[], byte[]> attributes);
      /// <summary>
      /// Get the specified number of versions for the specified table,
      /// row, and column.
      /// 
      /// @return list of cells for specified row/column
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="row">row key</param>
      /// <param name="column">column name</param>
      /// <param name="numVersions">number of versions to retrieve</param>
      /// <param name="attributes">Get attributes</param>
      List<TCell> getVer(byte[] tableName, byte[] row, byte[] column, int numVersions, Dictionary<byte[], byte[]> attributes);
      /// <summary>
      /// Get the specified number of versions for the specified table,
      /// row, and column.  Only versions less than or equal to the specified
      /// timestamp will be returned.
      /// 
      /// @return list of cells for specified row/column
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="row">row key</param>
      /// <param name="column">column name</param>
      /// <param name="timestamp">timestamp</param>
      /// <param name="numVersions">number of versions to retrieve</param>
      /// <param name="attributes">Get attributes</param>
      List<TCell> getVerTs(byte[] tableName, byte[] row, byte[] column, long timestamp, int numVersions, Dictionary<byte[], byte[]> attributes);
      /// <summary>
      /// Get all the data for the specified table and row at the latest
      /// timestamp. Returns an empty list if the row does not exist.
      /// 
      /// @return TRowResult containing the row and map of columns to TCells
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="row">row key</param>
      /// <param name="attributes">Get attributes</param>
      List<TRowResult> getRow(byte[] tableName, byte[] row, Dictionary<byte[], byte[]> attributes);
      /// <summary>
      /// Get the specified columns for the specified table and row at the latest
      /// timestamp. Returns an empty list if the row does not exist.
      /// 
      /// @return TRowResult containing the row and map of columns to TCells
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="row">row key</param>
      /// <param name="columns">List of columns to return, null for all columns</param>
      /// <param name="attributes">Get attributes</param>
      List<TRowResult> getRowWithColumns(byte[] tableName, byte[] row, List<byte[]> columns, Dictionary<byte[], byte[]> attributes);
      /// <summary>
      /// Get all the data for the specified table and row at the specified
      /// timestamp. Returns an empty list if the row does not exist.
      /// 
      /// @return TRowResult containing the row and map of columns to TCells
      /// </summary>
      /// <param name="tableName">name of the table</param>
      /// <param name="row">row key</param>
      /// <param name="timestamp">timestamp</param>
      /// <param name="attributes">Get attributes</param>
      List<TRowResult> getRowTs(byte[] tableName, byte[] row, long timestamp, Dictionary<byte[], byte[]> attributes);
      /// <summary>
      /// Get the specified columns for the specified table and row at the specified
      /// timestamp. Returns an empty list if the row does not exist.
      /// 
      /// @return TRowResult containing the row and map of columns to TCells
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="row">row key</param>
      /// <param name="columns">List of columns to return, null for all columns</param>
      /// <param name="timestamp"></param>
      /// <param name="attributes">Get attributes</param>
      List<TRowResult> getRowWithColumnsTs(byte[] tableName, byte[] row, List<byte[]> columns, long timestamp, Dictionary<byte[], byte[]> attributes);
      /// <summary>
      /// Get all the data for the specified table and rows at the latest
      /// timestamp. Returns an empty list if no rows exist.
      /// 
      /// @return TRowResult containing the rows and map of columns to TCells
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="rows">row keys</param>
      /// <param name="attributes">Get attributes</param>
      List<TRowResult> getRows(byte[] tableName, List<byte[]> rows, Dictionary<byte[], byte[]> attributes);
      /// <summary>
      /// Get the specified columns for the specified table and rows at the latest
      /// timestamp. Returns an empty list if no rows exist.
      /// 
      /// @return TRowResult containing the rows and map of columns to TCells
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="rows">row keys</param>
      /// <param name="columns">List of columns to return, null for all columns</param>
      /// <param name="attributes">Get attributes</param>
      List<TRowResult> getRowsWithColumns(byte[] tableName, List<byte[]> rows, List<byte[]> columns, Dictionary<byte[], byte[]> attributes);
      /// <summary>
      /// Get all the data for the specified table and rows at the specified
      /// timestamp. Returns an empty list if no rows exist.
      /// 
      /// @return TRowResult containing the rows and map of columns to TCells
      /// </summary>
      /// <param name="tableName">name of the table</param>
      /// <param name="rows">row keys</param>
      /// <param name="timestamp">timestamp</param>
      /// <param name="attributes">Get attributes</param>
      List<TRowResult> getRowsTs(byte[] tableName, List<byte[]> rows, long timestamp, Dictionary<byte[], byte[]> attributes);
      /// <summary>
      /// Get the specified columns for the specified table and rows at the specified
      /// timestamp. Returns an empty list if no rows exist.
      /// 
      /// @return TRowResult containing the rows and map of columns to TCells
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="rows">row keys</param>
      /// <param name="columns">List of columns to return, null for all columns</param>
      /// <param name="timestamp"></param>
      /// <param name="attributes">Get attributes</param>
      List<TRowResult> getRowsWithColumnsTs(byte[] tableName, List<byte[]> rows, List<byte[]> columns, long timestamp, Dictionary<byte[], byte[]> attributes);
      /// <summary>
      /// Apply a series of mutations (updates/deletes) to a row in a
      /// single transaction.  If an exception is thrown, then the
      /// transaction is aborted.  Default current timestamp is used, and
      /// all entries will have an identical timestamp.
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="row">row key</param>
      /// <param name="mutations">list of mutation commands</param>
      /// <param name="attributes">Mutation attributes</param>
      void mutateRow(byte[] tableName, byte[] row, List<Mutation> mutations, Dictionary<byte[], byte[]> attributes);
      /// <summary>
      /// Apply a series of mutations (updates/deletes) to a row in a
      /// single transaction.  If an exception is thrown, then the
      /// transaction is aborted.  The specified timestamp is used, and
      /// all entries will have an identical timestamp.
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="row">row key</param>
      /// <param name="mutations">list of mutation commands</param>
      /// <param name="timestamp">timestamp</param>
      /// <param name="attributes">Mutation attributes</param>
      void mutateRowTs(byte[] tableName, byte[] row, List<Mutation> mutations, long timestamp, Dictionary<byte[], byte[]> attributes);
      /// <summary>
      /// Apply a series of batches (each a series of mutations on a single row)
      /// in a single transaction.  If an exception is thrown, then the
      /// transaction is aborted.  Default current timestamp is used, and
      /// all entries will have an identical timestamp.
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="rowBatches">list of row batches</param>
      /// <param name="attributes">Mutation attributes</param>
      void mutateRows(byte[] tableName, List<BatchMutation> rowBatches, Dictionary<byte[], byte[]> attributes);
      /// <summary>
      /// Apply a series of batches (each a series of mutations on a single row)
      /// in a single transaction.  If an exception is thrown, then the
      /// transaction is aborted.  The specified timestamp is used, and
      /// all entries will have an identical timestamp.
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="rowBatches">list of row batches</param>
      /// <param name="timestamp">timestamp</param>
      /// <param name="attributes">Mutation attributes</param>
      void mutateRowsTs(byte[] tableName, List<BatchMutation> rowBatches, long timestamp, Dictionary<byte[], byte[]> attributes);
      /// <summary>
      /// Atomically increment the column value specified.  Returns the next value post increment.
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="row">row to increment</param>
      /// <param name="column">name of column</param>
      /// <param name="value">amount to increment by</param>
      long atomicIncrement(byte[] tableName, byte[] row, byte[] column, long @value);
      /// <summary>
      /// Delete all cells that match the passed row and column.
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="row">Row to update</param>
      /// <param name="column">name of column whose value is to be deleted</param>
      /// <param name="attributes">Delete attributes</param>
      void deleteAll(byte[] tableName, byte[] row, byte[] column, Dictionary<byte[], byte[]> attributes);
      /// <summary>
      /// Delete all cells that match the passed row and column and whose
      /// timestamp is equal-to or older than the passed timestamp.
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="row">Row to update</param>
      /// <param name="column">name of column whose value is to be deleted</param>
      /// <param name="timestamp">timestamp</param>
      /// <param name="attributes">Delete attributes</param>
      void deleteAllTs(byte[] tableName, byte[] row, byte[] column, long timestamp, Dictionary<byte[], byte[]> attributes);
      /// <summary>
      /// Completely delete the row's cells.
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="row">key of the row to be completely deleted.</param>
      /// <param name="attributes">Delete attributes</param>
      void deleteAllRow(byte[] tableName, byte[] row, Dictionary<byte[], byte[]> attributes);
      /// <summary>
      /// Increment a cell by the ammount.
      /// Increments can be applied async if hbase.regionserver.thrift.coalesceIncrement is set to true.
      /// False is the default.  Turn to true if you need the extra performance and can accept some
      /// data loss if a thrift server dies with increments still in the queue.
      /// </summary>
      /// <param name="increment">The single increment to apply</param>
      void increment(TIncrement increment);
      void incrementRows(List<TIncrement> increments);
      /// <summary>
      /// Completely delete the row's cells marked with a timestamp
      /// equal-to or older than the passed timestamp.
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="row">key of the row to be completely deleted.</param>
      /// <param name="timestamp">timestamp</param>
      /// <param name="attributes">Delete attributes</param>
      void deleteAllRowTs(byte[] tableName, byte[] row, long timestamp, Dictionary<byte[], byte[]> attributes);
      /// <summary>
      /// Get a scanner on the current table, using the Scan instance
      /// for the scan parameters.
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="scan">Scan instance</param>
      /// <param name="attributes">Scan attributes</param>
      int scannerOpenWithScan(byte[] tableName, TScan scan, Dictionary<byte[], byte[]> attributes);
      /// <summary>
      /// Get a scanner on the current table starting at the specified row and
      /// ending at the last row in the table.  Return the specified columns.
      /// 
      /// @return scanner id to be used with other scanner procedures
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="startRow">Starting row in table to scan.Send "" (empty string) to start at the first row.</param>
      /// <param name="columns">columns to scan. If column name is a column family, allcolumns of the specified column family are returned. It's also possibleto pass a regex in the column qualifier.</param>
      /// <param name="attributes">Scan attributes</param>
      int scannerOpen(byte[] tableName, byte[] startRow, List<byte[]> columns, Dictionary<byte[], byte[]> attributes);
      /// <summary>
      /// Get a scanner on the current table starting and stopping at the
      /// specified rows.  ending at the last row in the table.  Return the
      /// specified columns.
      /// 
      /// @return scanner id to be used with other scanner procedures
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="startRow">Starting row in table to scan.Send "" (empty string) to start at the first row.</param>
      /// <param name="stopRow">row to stop scanning on. This row is *not* included in thescanner's results</param>
      /// <param name="columns">columns to scan. If column name is a column family, allcolumns of the specified column family are returned. It's also possibleto pass a regex in the column qualifier.</param>
      /// <param name="attributes">Scan attributes</param>
      int scannerOpenWithStop(byte[] tableName, byte[] startRow, byte[] stopRow, List<byte[]> columns, Dictionary<byte[], byte[]> attributes);
      /// <summary>
      /// Open a scanner for a given prefix.  That is all rows will have the specified
      /// prefix. No other rows will be returned.
      /// 
      /// @return scanner id to use with other scanner calls
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="startAndPrefix">the prefix (and thus start row) of the keys you want</param>
      /// <param name="columns">the columns you want returned</param>
      /// <param name="attributes">Scan attributes</param>
      int scannerOpenWithPrefix(byte[] tableName, byte[] startAndPrefix, List<byte[]> columns, Dictionary<byte[], byte[]> attributes);
      /// <summary>
      /// Get a scanner on the current table starting at the specified row and
      /// ending at the last row in the table.  Return the specified columns.
      /// Only values with the specified timestamp are returned.
      /// 
      /// @return scanner id to be used with other scanner procedures
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="startRow">Starting row in table to scan.Send "" (empty string) to start at the first row.</param>
      /// <param name="columns">columns to scan. If column name is a column family, allcolumns of the specified column family are returned. It's also possibleto pass a regex in the column qualifier.</param>
      /// <param name="timestamp">timestamp</param>
      /// <param name="attributes">Scan attributes</param>
      int scannerOpenTs(byte[] tableName, byte[] startRow, List<byte[]> columns, long timestamp, Dictionary<byte[], byte[]> attributes);
      /// <summary>
      /// Get a scanner on the current table starting and stopping at the
      /// specified rows.  ending at the last row in the table.  Return the
      /// specified columns.  Only values with the specified timestamp are
      /// returned.
      /// 
      /// @return scanner id to be used with other scanner procedures
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="startRow">Starting row in table to scan.Send "" (empty string) to start at the first row.</param>
      /// <param name="stopRow">row to stop scanning on. This row is *not* included in thescanner's results</param>
      /// <param name="columns">columns to scan. If column name is a column family, allcolumns of the specified column family are returned. It's also possibleto pass a regex in the column qualifier.</param>
      /// <param name="timestamp">timestamp</param>
      /// <param name="attributes">Scan attributes</param>
      int scannerOpenWithStopTs(byte[] tableName, byte[] startRow, byte[] stopRow, List<byte[]> columns, long timestamp, Dictionary<byte[], byte[]> attributes);
      /// <summary>
      /// Returns the scanner's current row value and advances to the next
      /// row in the table.  When there are no more rows in the table, or a key
      /// greater-than-or-equal-to the scanner's specified stopRow is reached,
      /// an empty list is returned.
      /// 
      /// @return a TRowResult containing the current row and a map of the columns to TCells.
      /// 
      /// @throws IllegalArgument if ScannerID is invalid
      /// 
      /// @throws NotFound when the scanner reaches the end
      /// </summary>
      /// <param name="id">id of a scanner returned by scannerOpen</param>
      List<TRowResult> scannerGet(int id);
      /// <summary>
      /// Returns, starting at the scanner's current row value nbRows worth of
      /// rows and advances to the next row in the table.  When there are no more
      /// rows in the table, or a key greater-than-or-equal-to the scanner's
      /// specified stopRow is reached,  an empty list is returned.
      /// 
      /// @return a TRowResult containing the current row and a map of the columns to TCells.
      /// 
      /// @throws IllegalArgument if ScannerID is invalid
      /// 
      /// @throws NotFound when the scanner reaches the end
      /// </summary>
      /// <param name="id">id of a scanner returned by scannerOpen</param>
      /// <param name="nbRows">number of results to return</param>
      List<TRowResult> scannerGetList(int id, int nbRows);
      /// <summary>
      /// Closes the server-state associated with an open scanner.
      /// 
      /// @throws IllegalArgument if ScannerID is invalid
      /// </summary>
      /// <param name="id">id of a scanner returned by scannerOpen</param>
      void scannerClose(int id);
      /// <summary>
      /// Get the row just before the specified one.
      /// 
      /// @return value for specified row/column
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="row">row key</param>
      /// <param name="family">column name</param>
      List<TCell> getRowOrBefore(byte[] tableName, byte[] row, byte[] family);
      /// <summary>
      /// Get the regininfo for the specified row. It scans
      /// the metatable to find region's start and end keys.
      /// 
      /// @return value for specified row/column
      /// </summary>
      /// <param name="row">row key</param>
      TRegionInfo getRegionInfo(byte[] row);
      /// <summary>
      /// Appends values to one or more columns within a single row.
      /// 
      /// @return values of columns after the append operation.
      /// </summary>
      /// <param name="append">The single append operation to apply</param>
      List<TCell> append(TAppend append);
      /// <summary>
      /// Atomically checks if a row/family/qualifier value matches the expected
      /// value. If it does, it adds the corresponding mutation operation for put.
      /// 
      /// @return true if the new put was executed, false otherwise
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="row">row key</param>
      /// <param name="column">column name</param>
      /// <param name="value">the expected value for the column parameter, if notprovided the check is for the non-existence of thecolumn in question</param>
      /// <param name="mput">mutation for the put</param>
      /// <param name="attributes">Mutation attributes</param>
      bool checkAndPut(byte[] tableName, byte[] row, byte[] column, byte[] @value, Mutation mput, Dictionary<byte[], byte[]> attributes);
    }

    public interface Iface : ISync {
      /// <summary>
      /// Brings a table on-line (enables it)
      /// </summary>
      /// <param name="tableName">name of the table</param>
      #if SILVERLIGHT
      IAsyncResult Begin_enableTable(AsyncCallback callback, object state, byte[] tableName);
      void End_enableTable(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Disables a table (takes it off-line) If it is being served, the master
      /// will tell the servers to stop serving it.
      /// </summary>
      /// <param name="tableName">name of the table</param>
      #if SILVERLIGHT
      IAsyncResult Begin_disableTable(AsyncCallback callback, object state, byte[] tableName);
      void End_disableTable(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// @return true if table is on-line
      /// </summary>
      /// <param name="tableName">name of the table to check</param>
      #if SILVERLIGHT
      IAsyncResult Begin_isTableEnabled(AsyncCallback callback, object state, byte[] tableName);
      bool End_isTableEnabled(IAsyncResult asyncResult);
      #endif
      #if SILVERLIGHT
      IAsyncResult Begin_compact(AsyncCallback callback, object state, byte[] tableNameOrRegionName);
      void End_compact(IAsyncResult asyncResult);
      #endif
      #if SILVERLIGHT
      IAsyncResult Begin_majorCompact(AsyncCallback callback, object state, byte[] tableNameOrRegionName);
      void End_majorCompact(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// List all the userspace tables.
      /// 
      /// @return returns a list of names
      /// </summary>
      #if SILVERLIGHT
      IAsyncResult Begin_getTableNames(AsyncCallback callback, object state);
      List<byte[]> End_getTableNames(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// List all the column families assoicated with a table.
      /// 
      /// @return list of column family descriptors
      /// </summary>
      /// <param name="tableName">table name</param>
      #if SILVERLIGHT
      IAsyncResult Begin_getColumnDescriptors(AsyncCallback callback, object state, byte[] tableName);
      Dictionary<byte[], ColumnDescriptor> End_getColumnDescriptors(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// List the regions associated with a table.
      /// 
      /// @return list of region descriptors
      /// </summary>
      /// <param name="tableName">table name</param>
      #if SILVERLIGHT
      IAsyncResult Begin_getTableRegions(AsyncCallback callback, object state, byte[] tableName);
      List<TRegionInfo> End_getTableRegions(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Create a table with the specified column families.  The name
      /// field for each ColumnDescriptor must be set and must end in a
      /// colon (:). All other fields are optional and will get default
      /// values if not explicitly specified.
      /// 
      /// @throws IllegalArgument if an input parameter is invalid
      /// 
      /// @throws AlreadyExists if the table name already exists
      /// </summary>
      /// <param name="tableName">name of table to create</param>
      /// <param name="columnFamilies">list of column family descriptors</param>
      #if SILVERLIGHT
      IAsyncResult Begin_createTable(AsyncCallback callback, object state, byte[] tableName, List<ColumnDescriptor> columnFamilies);
      void End_createTable(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Deletes a table
      /// 
      /// @throws IOError if table doesn't exist on server or there was some other
      /// problem
      /// </summary>
      /// <param name="tableName">name of table to delete</param>
      #if SILVERLIGHT
      IAsyncResult Begin_deleteTable(AsyncCallback callback, object state, byte[] tableName);
      void End_deleteTable(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Get a single TCell for the specified table, row, and column at the
      /// latest timestamp. Returns an empty list if no such value exists.
      /// 
      /// @return value for specified row/column
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="row">row key</param>
      /// <param name="column">column name</param>
      /// <param name="attributes">Get attributes</param>
      #if SILVERLIGHT
      IAsyncResult Begin_get(AsyncCallback callback, object state, byte[] tableName, byte[] row, byte[] column, Dictionary<byte[], byte[]> attributes);
      List<TCell> End_get(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Get the specified number of versions for the specified table,
      /// row, and column.
      /// 
      /// @return list of cells for specified row/column
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="row">row key</param>
      /// <param name="column">column name</param>
      /// <param name="numVersions">number of versions to retrieve</param>
      /// <param name="attributes">Get attributes</param>
      #if SILVERLIGHT
      IAsyncResult Begin_getVer(AsyncCallback callback, object state, byte[] tableName, byte[] row, byte[] column, int numVersions, Dictionary<byte[], byte[]> attributes);
      List<TCell> End_getVer(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Get the specified number of versions for the specified table,
      /// row, and column.  Only versions less than or equal to the specified
      /// timestamp will be returned.
      /// 
      /// @return list of cells for specified row/column
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="row">row key</param>
      /// <param name="column">column name</param>
      /// <param name="timestamp">timestamp</param>
      /// <param name="numVersions">number of versions to retrieve</param>
      /// <param name="attributes">Get attributes</param>
      #if SILVERLIGHT
      IAsyncResult Begin_getVerTs(AsyncCallback callback, object state, byte[] tableName, byte[] row, byte[] column, long timestamp, int numVersions, Dictionary<byte[], byte[]> attributes);
      List<TCell> End_getVerTs(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Get all the data for the specified table and row at the latest
      /// timestamp. Returns an empty list if the row does not exist.
      /// 
      /// @return TRowResult containing the row and map of columns to TCells
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="row">row key</param>
      /// <param name="attributes">Get attributes</param>
      #if SILVERLIGHT
      IAsyncResult Begin_getRow(AsyncCallback callback, object state, byte[] tableName, byte[] row, Dictionary<byte[], byte[]> attributes);
      List<TRowResult> End_getRow(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Get the specified columns for the specified table and row at the latest
      /// timestamp. Returns an empty list if the row does not exist.
      /// 
      /// @return TRowResult containing the row and map of columns to TCells
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="row">row key</param>
      /// <param name="columns">List of columns to return, null for all columns</param>
      /// <param name="attributes">Get attributes</param>
      #if SILVERLIGHT
      IAsyncResult Begin_getRowWithColumns(AsyncCallback callback, object state, byte[] tableName, byte[] row, List<byte[]> columns, Dictionary<byte[], byte[]> attributes);
      List<TRowResult> End_getRowWithColumns(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Get all the data for the specified table and row at the specified
      /// timestamp. Returns an empty list if the row does not exist.
      /// 
      /// @return TRowResult containing the row and map of columns to TCells
      /// </summary>
      /// <param name="tableName">name of the table</param>
      /// <param name="row">row key</param>
      /// <param name="timestamp">timestamp</param>
      /// <param name="attributes">Get attributes</param>
      #if SILVERLIGHT
      IAsyncResult Begin_getRowTs(AsyncCallback callback, object state, byte[] tableName, byte[] row, long timestamp, Dictionary<byte[], byte[]> attributes);
      List<TRowResult> End_getRowTs(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Get the specified columns for the specified table and row at the specified
      /// timestamp. Returns an empty list if the row does not exist.
      /// 
      /// @return TRowResult containing the row and map of columns to TCells
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="row">row key</param>
      /// <param name="columns">List of columns to return, null for all columns</param>
      /// <param name="timestamp"></param>
      /// <param name="attributes">Get attributes</param>
      #if SILVERLIGHT
      IAsyncResult Begin_getRowWithColumnsTs(AsyncCallback callback, object state, byte[] tableName, byte[] row, List<byte[]> columns, long timestamp, Dictionary<byte[], byte[]> attributes);
      List<TRowResult> End_getRowWithColumnsTs(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Get all the data for the specified table and rows at the latest
      /// timestamp. Returns an empty list if no rows exist.
      /// 
      /// @return TRowResult containing the rows and map of columns to TCells
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="rows">row keys</param>
      /// <param name="attributes">Get attributes</param>
      #if SILVERLIGHT
      IAsyncResult Begin_getRows(AsyncCallback callback, object state, byte[] tableName, List<byte[]> rows, Dictionary<byte[], byte[]> attributes);
      List<TRowResult> End_getRows(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Get the specified columns for the specified table and rows at the latest
      /// timestamp. Returns an empty list if no rows exist.
      /// 
      /// @return TRowResult containing the rows and map of columns to TCells
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="rows">row keys</param>
      /// <param name="columns">List of columns to return, null for all columns</param>
      /// <param name="attributes">Get attributes</param>
      #if SILVERLIGHT
      IAsyncResult Begin_getRowsWithColumns(AsyncCallback callback, object state, byte[] tableName, List<byte[]> rows, List<byte[]> columns, Dictionary<byte[], byte[]> attributes);
      List<TRowResult> End_getRowsWithColumns(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Get all the data for the specified table and rows at the specified
      /// timestamp. Returns an empty list if no rows exist.
      /// 
      /// @return TRowResult containing the rows and map of columns to TCells
      /// </summary>
      /// <param name="tableName">name of the table</param>
      /// <param name="rows">row keys</param>
      /// <param name="timestamp">timestamp</param>
      /// <param name="attributes">Get attributes</param>
      #if SILVERLIGHT
      IAsyncResult Begin_getRowsTs(AsyncCallback callback, object state, byte[] tableName, List<byte[]> rows, long timestamp, Dictionary<byte[], byte[]> attributes);
      List<TRowResult> End_getRowsTs(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Get the specified columns for the specified table and rows at the specified
      /// timestamp. Returns an empty list if no rows exist.
      /// 
      /// @return TRowResult containing the rows and map of columns to TCells
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="rows">row keys</param>
      /// <param name="columns">List of columns to return, null for all columns</param>
      /// <param name="timestamp"></param>
      /// <param name="attributes">Get attributes</param>
      #if SILVERLIGHT
      IAsyncResult Begin_getRowsWithColumnsTs(AsyncCallback callback, object state, byte[] tableName, List<byte[]> rows, List<byte[]> columns, long timestamp, Dictionary<byte[], byte[]> attributes);
      List<TRowResult> End_getRowsWithColumnsTs(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Apply a series of mutations (updates/deletes) to a row in a
      /// single transaction.  If an exception is thrown, then the
      /// transaction is aborted.  Default current timestamp is used, and
      /// all entries will have an identical timestamp.
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="row">row key</param>
      /// <param name="mutations">list of mutation commands</param>
      /// <param name="attributes">Mutation attributes</param>
      #if SILVERLIGHT
      IAsyncResult Begin_mutateRow(AsyncCallback callback, object state, byte[] tableName, byte[] row, List<Mutation> mutations, Dictionary<byte[], byte[]> attributes);
      void End_mutateRow(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Apply a series of mutations (updates/deletes) to a row in a
      /// single transaction.  If an exception is thrown, then the
      /// transaction is aborted.  The specified timestamp is used, and
      /// all entries will have an identical timestamp.
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="row">row key</param>
      /// <param name="mutations">list of mutation commands</param>
      /// <param name="timestamp">timestamp</param>
      /// <param name="attributes">Mutation attributes</param>
      #if SILVERLIGHT
      IAsyncResult Begin_mutateRowTs(AsyncCallback callback, object state, byte[] tableName, byte[] row, List<Mutation> mutations, long timestamp, Dictionary<byte[], byte[]> attributes);
      void End_mutateRowTs(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Apply a series of batches (each a series of mutations on a single row)
      /// in a single transaction.  If an exception is thrown, then the
      /// transaction is aborted.  Default current timestamp is used, and
      /// all entries will have an identical timestamp.
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="rowBatches">list of row batches</param>
      /// <param name="attributes">Mutation attributes</param>
      #if SILVERLIGHT
      IAsyncResult Begin_mutateRows(AsyncCallback callback, object state, byte[] tableName, List<BatchMutation> rowBatches, Dictionary<byte[], byte[]> attributes);
      void End_mutateRows(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Apply a series of batches (each a series of mutations on a single row)
      /// in a single transaction.  If an exception is thrown, then the
      /// transaction is aborted.  The specified timestamp is used, and
      /// all entries will have an identical timestamp.
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="rowBatches">list of row batches</param>
      /// <param name="timestamp">timestamp</param>
      /// <param name="attributes">Mutation attributes</param>
      #if SILVERLIGHT
      IAsyncResult Begin_mutateRowsTs(AsyncCallback callback, object state, byte[] tableName, List<BatchMutation> rowBatches, long timestamp, Dictionary<byte[], byte[]> attributes);
      void End_mutateRowsTs(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Atomically increment the column value specified.  Returns the next value post increment.
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="row">row to increment</param>
      /// <param name="column">name of column</param>
      /// <param name="value">amount to increment by</param>
      #if SILVERLIGHT
      IAsyncResult Begin_atomicIncrement(AsyncCallback callback, object state, byte[] tableName, byte[] row, byte[] column, long @value);
      long End_atomicIncrement(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Delete all cells that match the passed row and column.
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="row">Row to update</param>
      /// <param name="column">name of column whose value is to be deleted</param>
      /// <param name="attributes">Delete attributes</param>
      #if SILVERLIGHT
      IAsyncResult Begin_deleteAll(AsyncCallback callback, object state, byte[] tableName, byte[] row, byte[] column, Dictionary<byte[], byte[]> attributes);
      void End_deleteAll(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Delete all cells that match the passed row and column and whose
      /// timestamp is equal-to or older than the passed timestamp.
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="row">Row to update</param>
      /// <param name="column">name of column whose value is to be deleted</param>
      /// <param name="timestamp">timestamp</param>
      /// <param name="attributes">Delete attributes</param>
      #if SILVERLIGHT
      IAsyncResult Begin_deleteAllTs(AsyncCallback callback, object state, byte[] tableName, byte[] row, byte[] column, long timestamp, Dictionary<byte[], byte[]> attributes);
      void End_deleteAllTs(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Completely delete the row's cells.
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="row">key of the row to be completely deleted.</param>
      /// <param name="attributes">Delete attributes</param>
      #if SILVERLIGHT
      IAsyncResult Begin_deleteAllRow(AsyncCallback callback, object state, byte[] tableName, byte[] row, Dictionary<byte[], byte[]> attributes);
      void End_deleteAllRow(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Increment a cell by the ammount.
      /// Increments can be applied async if hbase.regionserver.thrift.coalesceIncrement is set to true.
      /// False is the default.  Turn to true if you need the extra performance and can accept some
      /// data loss if a thrift server dies with increments still in the queue.
      /// </summary>
      /// <param name="increment">The single increment to apply</param>
      #if SILVERLIGHT
      IAsyncResult Begin_increment(AsyncCallback callback, object state, TIncrement increment);
      void End_increment(IAsyncResult asyncResult);
      #endif
      #if SILVERLIGHT
      IAsyncResult Begin_incrementRows(AsyncCallback callback, object state, List<TIncrement> increments);
      void End_incrementRows(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Completely delete the row's cells marked with a timestamp
      /// equal-to or older than the passed timestamp.
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="row">key of the row to be completely deleted.</param>
      /// <param name="timestamp">timestamp</param>
      /// <param name="attributes">Delete attributes</param>
      #if SILVERLIGHT
      IAsyncResult Begin_deleteAllRowTs(AsyncCallback callback, object state, byte[] tableName, byte[] row, long timestamp, Dictionary<byte[], byte[]> attributes);
      void End_deleteAllRowTs(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Get a scanner on the current table, using the Scan instance
      /// for the scan parameters.
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="scan">Scan instance</param>
      /// <param name="attributes">Scan attributes</param>
      #if SILVERLIGHT
      IAsyncResult Begin_scannerOpenWithScan(AsyncCallback callback, object state, byte[] tableName, TScan scan, Dictionary<byte[], byte[]> attributes);
      int End_scannerOpenWithScan(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Get a scanner on the current table starting at the specified row and
      /// ending at the last row in the table.  Return the specified columns.
      /// 
      /// @return scanner id to be used with other scanner procedures
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="startRow">Starting row in table to scan.Send "" (empty string) to start at the first row.</param>
      /// <param name="columns">columns to scan. If column name is a column family, allcolumns of the specified column family are returned. It's also possibleto pass a regex in the column qualifier.</param>
      /// <param name="attributes">Scan attributes</param>
      #if SILVERLIGHT
      IAsyncResult Begin_scannerOpen(AsyncCallback callback, object state, byte[] tableName, byte[] startRow, List<byte[]> columns, Dictionary<byte[], byte[]> attributes);
      int End_scannerOpen(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Get a scanner on the current table starting and stopping at the
      /// specified rows.  ending at the last row in the table.  Return the
      /// specified columns.
      /// 
      /// @return scanner id to be used with other scanner procedures
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="startRow">Starting row in table to scan.Send "" (empty string) to start at the first row.</param>
      /// <param name="stopRow">row to stop scanning on. This row is *not* included in thescanner's results</param>
      /// <param name="columns">columns to scan. If column name is a column family, allcolumns of the specified column family are returned. It's also possibleto pass a regex in the column qualifier.</param>
      /// <param name="attributes">Scan attributes</param>
      #if SILVERLIGHT
      IAsyncResult Begin_scannerOpenWithStop(AsyncCallback callback, object state, byte[] tableName, byte[] startRow, byte[] stopRow, List<byte[]> columns, Dictionary<byte[], byte[]> attributes);
      int End_scannerOpenWithStop(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Open a scanner for a given prefix.  That is all rows will have the specified
      /// prefix. No other rows will be returned.
      /// 
      /// @return scanner id to use with other scanner calls
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="startAndPrefix">the prefix (and thus start row) of the keys you want</param>
      /// <param name="columns">the columns you want returned</param>
      /// <param name="attributes">Scan attributes</param>
      #if SILVERLIGHT
      IAsyncResult Begin_scannerOpenWithPrefix(AsyncCallback callback, object state, byte[] tableName, byte[] startAndPrefix, List<byte[]> columns, Dictionary<byte[], byte[]> attributes);
      int End_scannerOpenWithPrefix(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Get a scanner on the current table starting at the specified row and
      /// ending at the last row in the table.  Return the specified columns.
      /// Only values with the specified timestamp are returned.
      /// 
      /// @return scanner id to be used with other scanner procedures
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="startRow">Starting row in table to scan.Send "" (empty string) to start at the first row.</param>
      /// <param name="columns">columns to scan. If column name is a column family, allcolumns of the specified column family are returned. It's also possibleto pass a regex in the column qualifier.</param>
      /// <param name="timestamp">timestamp</param>
      /// <param name="attributes">Scan attributes</param>
      #if SILVERLIGHT
      IAsyncResult Begin_scannerOpenTs(AsyncCallback callback, object state, byte[] tableName, byte[] startRow, List<byte[]> columns, long timestamp, Dictionary<byte[], byte[]> attributes);
      int End_scannerOpenTs(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Get a scanner on the current table starting and stopping at the
      /// specified rows.  ending at the last row in the table.  Return the
      /// specified columns.  Only values with the specified timestamp are
      /// returned.
      /// 
      /// @return scanner id to be used with other scanner procedures
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="startRow">Starting row in table to scan.Send "" (empty string) to start at the first row.</param>
      /// <param name="stopRow">row to stop scanning on. This row is *not* included in thescanner's results</param>
      /// <param name="columns">columns to scan. If column name is a column family, allcolumns of the specified column family are returned. It's also possibleto pass a regex in the column qualifier.</param>
      /// <param name="timestamp">timestamp</param>
      /// <param name="attributes">Scan attributes</param>
      #if SILVERLIGHT
      IAsyncResult Begin_scannerOpenWithStopTs(AsyncCallback callback, object state, byte[] tableName, byte[] startRow, byte[] stopRow, List<byte[]> columns, long timestamp, Dictionary<byte[], byte[]> attributes);
      int End_scannerOpenWithStopTs(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Returns the scanner's current row value and advances to the next
      /// row in the table.  When there are no more rows in the table, or a key
      /// greater-than-or-equal-to the scanner's specified stopRow is reached,
      /// an empty list is returned.
      /// 
      /// @return a TRowResult containing the current row and a map of the columns to TCells.
      /// 
      /// @throws IllegalArgument if ScannerID is invalid
      /// 
      /// @throws NotFound when the scanner reaches the end
      /// </summary>
      /// <param name="id">id of a scanner returned by scannerOpen</param>
      #if SILVERLIGHT
      IAsyncResult Begin_scannerGet(AsyncCallback callback, object state, int id);
      List<TRowResult> End_scannerGet(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Returns, starting at the scanner's current row value nbRows worth of
      /// rows and advances to the next row in the table.  When there are no more
      /// rows in the table, or a key greater-than-or-equal-to the scanner's
      /// specified stopRow is reached,  an empty list is returned.
      /// 
      /// @return a TRowResult containing the current row and a map of the columns to TCells.
      /// 
      /// @throws IllegalArgument if ScannerID is invalid
      /// 
      /// @throws NotFound when the scanner reaches the end
      /// </summary>
      /// <param name="id">id of a scanner returned by scannerOpen</param>
      /// <param name="nbRows">number of results to return</param>
      #if SILVERLIGHT
      IAsyncResult Begin_scannerGetList(AsyncCallback callback, object state, int id, int nbRows);
      List<TRowResult> End_scannerGetList(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Closes the server-state associated with an open scanner.
      /// 
      /// @throws IllegalArgument if ScannerID is invalid
      /// </summary>
      /// <param name="id">id of a scanner returned by scannerOpen</param>
      #if SILVERLIGHT
      IAsyncResult Begin_scannerClose(AsyncCallback callback, object state, int id);
      void End_scannerClose(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Get the row just before the specified one.
      /// 
      /// @return value for specified row/column
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="row">row key</param>
      /// <param name="family">column name</param>
      #if SILVERLIGHT
      IAsyncResult Begin_getRowOrBefore(AsyncCallback callback, object state, byte[] tableName, byte[] row, byte[] family);
      List<TCell> End_getRowOrBefore(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Get the regininfo for the specified row. It scans
      /// the metatable to find region's start and end keys.
      /// 
      /// @return value for specified row/column
      /// </summary>
      /// <param name="row">row key</param>
      #if SILVERLIGHT
      IAsyncResult Begin_getRegionInfo(AsyncCallback callback, object state, byte[] row);
      TRegionInfo End_getRegionInfo(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Appends values to one or more columns within a single row.
      /// 
      /// @return values of columns after the append operation.
      /// </summary>
      /// <param name="append">The single append operation to apply</param>
      #if SILVERLIGHT
      IAsyncResult Begin_append(AsyncCallback callback, object state, TAppend append);
      List<TCell> End_append(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Atomically checks if a row/family/qualifier value matches the expected
      /// value. If it does, it adds the corresponding mutation operation for put.
      /// 
      /// @return true if the new put was executed, false otherwise
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="row">row key</param>
      /// <param name="column">column name</param>
      /// <param name="value">the expected value for the column parameter, if notprovided the check is for the non-existence of thecolumn in question</param>
      /// <param name="mput">mutation for the put</param>
      /// <param name="attributes">Mutation attributes</param>
      #if SILVERLIGHT
      IAsyncResult Begin_checkAndPut(AsyncCallback callback, object state, byte[] tableName, byte[] row, byte[] column, byte[] @value, Mutation mput, Dictionary<byte[], byte[]> attributes);
      bool End_checkAndPut(IAsyncResult asyncResult);
      #endif
    }

    public class Client : IDisposable, Iface {
      public Client(TProtocol prot) : this(prot, prot)
      {
      }

      public Client(TProtocol iprot, TProtocol oprot)
      {
        iprot_ = iprot;
        oprot_ = oprot;
      }

      protected TProtocol iprot_;
      protected TProtocol oprot_;
      protected int seqid_;

      public TProtocol InputProtocol
      {
        get { return iprot_; }
      }
      public TProtocol OutputProtocol
      {
        get { return oprot_; }
      }


      #region " IDisposable Support "
      private bool _IsDisposed;

      // IDisposable
      public void Dispose()
      {
        Dispose(true);
      }
      

      protected virtual void Dispose(bool disposing)
      {
        if (!_IsDisposed)
        {
          if (disposing)
          {
            if (iprot_ != null)
            {
              ((IDisposable)iprot_).Dispose();
            }
            if (oprot_ != null)
            {
              ((IDisposable)oprot_).Dispose();
            }
          }
        }
        _IsDisposed = true;
      }
      #endregion


      
      #if SILVERLIGHT
      public IAsyncResult Begin_enableTable(AsyncCallback callback, object state, byte[] tableName)
      {
        return send_enableTable(callback, state, tableName);
      }

      public void End_enableTable(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        recv_enableTable();
      }

      #endif

      /// <summary>
      /// Brings a table on-line (enables it)
      /// </summary>
      /// <param name="tableName">name of the table</param>
      public void enableTable(byte[] tableName)
      {
        #if !SILVERLIGHT
        send_enableTable(tableName);
        recv_enableTable();

        #else
        var asyncResult = Begin_enableTable(null, null, tableName);
        End_enableTable(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_enableTable(AsyncCallback callback, object state, byte[] tableName)
      #else
      public void send_enableTable(byte[] tableName)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("enableTable", TMessageType.Call, seqid_));
        enableTable_args args = new enableTable_args();
        args.TableName = tableName;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public void recv_enableTable()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        enableTable_result result = new enableTable_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.io) {
          throw result.Io;
        }
        return;
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_disableTable(AsyncCallback callback, object state, byte[] tableName)
      {
        return send_disableTable(callback, state, tableName);
      }

      public void End_disableTable(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        recv_disableTable();
      }

      #endif

      /// <summary>
      /// Disables a table (takes it off-line) If it is being served, the master
      /// will tell the servers to stop serving it.
      /// </summary>
      /// <param name="tableName">name of the table</param>
      public void disableTable(byte[] tableName)
      {
        #if !SILVERLIGHT
        send_disableTable(tableName);
        recv_disableTable();

        #else
        var asyncResult = Begin_disableTable(null, null, tableName);
        End_disableTable(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_disableTable(AsyncCallback callback, object state, byte[] tableName)
      #else
      public void send_disableTable(byte[] tableName)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("disableTable", TMessageType.Call, seqid_));
        disableTable_args args = new disableTable_args();
        args.TableName = tableName;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public void recv_disableTable()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        disableTable_result result = new disableTable_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.io) {
          throw result.Io;
        }
        return;
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_isTableEnabled(AsyncCallback callback, object state, byte[] tableName)
      {
        return send_isTableEnabled(callback, state, tableName);
      }

      public bool End_isTableEnabled(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_isTableEnabled();
      }

      #endif

      /// <summary>
      /// @return true if table is on-line
      /// </summary>
      /// <param name="tableName">name of the table to check</param>
      public bool isTableEnabled(byte[] tableName)
      {
        #if !SILVERLIGHT
        send_isTableEnabled(tableName);
        return recv_isTableEnabled();

        #else
        var asyncResult = Begin_isTableEnabled(null, null, tableName);
        return End_isTableEnabled(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_isTableEnabled(AsyncCallback callback, object state, byte[] tableName)
      #else
      public void send_isTableEnabled(byte[] tableName)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("isTableEnabled", TMessageType.Call, seqid_));
        isTableEnabled_args args = new isTableEnabled_args();
        args.TableName = tableName;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public bool recv_isTableEnabled()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        isTableEnabled_result result = new isTableEnabled_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.io) {
          throw result.Io;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "isTableEnabled failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_compact(AsyncCallback callback, object state, byte[] tableNameOrRegionName)
      {
        return send_compact(callback, state, tableNameOrRegionName);
      }

      public void End_compact(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        recv_compact();
      }

      #endif

      public void compact(byte[] tableNameOrRegionName)
      {
        #if !SILVERLIGHT
        send_compact(tableNameOrRegionName);
        recv_compact();

        #else
        var asyncResult = Begin_compact(null, null, tableNameOrRegionName);
        End_compact(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_compact(AsyncCallback callback, object state, byte[] tableNameOrRegionName)
      #else
      public void send_compact(byte[] tableNameOrRegionName)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("compact", TMessageType.Call, seqid_));
        compact_args args = new compact_args();
        args.TableNameOrRegionName = tableNameOrRegionName;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public void recv_compact()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        compact_result result = new compact_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.io) {
          throw result.Io;
        }
        return;
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_majorCompact(AsyncCallback callback, object state, byte[] tableNameOrRegionName)
      {
        return send_majorCompact(callback, state, tableNameOrRegionName);
      }

      public void End_majorCompact(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        recv_majorCompact();
      }

      #endif

      public void majorCompact(byte[] tableNameOrRegionName)
      {
        #if !SILVERLIGHT
        send_majorCompact(tableNameOrRegionName);
        recv_majorCompact();

        #else
        var asyncResult = Begin_majorCompact(null, null, tableNameOrRegionName);
        End_majorCompact(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_majorCompact(AsyncCallback callback, object state, byte[] tableNameOrRegionName)
      #else
      public void send_majorCompact(byte[] tableNameOrRegionName)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("majorCompact", TMessageType.Call, seqid_));
        majorCompact_args args = new majorCompact_args();
        args.TableNameOrRegionName = tableNameOrRegionName;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public void recv_majorCompact()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        majorCompact_result result = new majorCompact_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.io) {
          throw result.Io;
        }
        return;
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_getTableNames(AsyncCallback callback, object state)
      {
        return send_getTableNames(callback, state);
      }

      public List<byte[]> End_getTableNames(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_getTableNames();
      }

      #endif

      /// <summary>
      /// List all the userspace tables.
      /// 
      /// @return returns a list of names
      /// </summary>
      public List<byte[]> getTableNames()
      {
        #if !SILVERLIGHT
        send_getTableNames();
        return recv_getTableNames();

        #else
        var asyncResult = Begin_getTableNames(null, null);
        return End_getTableNames(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_getTableNames(AsyncCallback callback, object state)
      #else
      public void send_getTableNames()
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("getTableNames", TMessageType.Call, seqid_));
        getTableNames_args args = new getTableNames_args();
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public List<byte[]> recv_getTableNames()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        getTableNames_result result = new getTableNames_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.io) {
          throw result.Io;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getTableNames failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_getColumnDescriptors(AsyncCallback callback, object state, byte[] tableName)
      {
        return send_getColumnDescriptors(callback, state, tableName);
      }

      public Dictionary<byte[], ColumnDescriptor> End_getColumnDescriptors(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_getColumnDescriptors();
      }

      #endif

      /// <summary>
      /// List all the column families assoicated with a table.
      /// 
      /// @return list of column family descriptors
      /// </summary>
      /// <param name="tableName">table name</param>
      public Dictionary<byte[], ColumnDescriptor> getColumnDescriptors(byte[] tableName)
      {
        #if !SILVERLIGHT
        send_getColumnDescriptors(tableName);
        return recv_getColumnDescriptors();

        #else
        var asyncResult = Begin_getColumnDescriptors(null, null, tableName);
        return End_getColumnDescriptors(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_getColumnDescriptors(AsyncCallback callback, object state, byte[] tableName)
      #else
      public void send_getColumnDescriptors(byte[] tableName)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("getColumnDescriptors", TMessageType.Call, seqid_));
        getColumnDescriptors_args args = new getColumnDescriptors_args();
        args.TableName = tableName;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public Dictionary<byte[], ColumnDescriptor> recv_getColumnDescriptors()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        getColumnDescriptors_result result = new getColumnDescriptors_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.io) {
          throw result.Io;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getColumnDescriptors failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_getTableRegions(AsyncCallback callback, object state, byte[] tableName)
      {
        return send_getTableRegions(callback, state, tableName);
      }

      public List<TRegionInfo> End_getTableRegions(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_getTableRegions();
      }

      #endif

      /// <summary>
      /// List the regions associated with a table.
      /// 
      /// @return list of region descriptors
      /// </summary>
      /// <param name="tableName">table name</param>
      public List<TRegionInfo> getTableRegions(byte[] tableName)
      {
        #if !SILVERLIGHT
        send_getTableRegions(tableName);
        return recv_getTableRegions();

        #else
        var asyncResult = Begin_getTableRegions(null, null, tableName);
        return End_getTableRegions(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_getTableRegions(AsyncCallback callback, object state, byte[] tableName)
      #else
      public void send_getTableRegions(byte[] tableName)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("getTableRegions", TMessageType.Call, seqid_));
        getTableRegions_args args = new getTableRegions_args();
        args.TableName = tableName;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public List<TRegionInfo> recv_getTableRegions()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        getTableRegions_result result = new getTableRegions_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.io) {
          throw result.Io;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getTableRegions failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_createTable(AsyncCallback callback, object state, byte[] tableName, List<ColumnDescriptor> columnFamilies)
      {
        return send_createTable(callback, state, tableName, columnFamilies);
      }

      public void End_createTable(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        recv_createTable();
      }

      #endif

      /// <summary>
      /// Create a table with the specified column families.  The name
      /// field for each ColumnDescriptor must be set and must end in a
      /// colon (:). All other fields are optional and will get default
      /// values if not explicitly specified.
      /// 
      /// @throws IllegalArgument if an input parameter is invalid
      /// 
      /// @throws AlreadyExists if the table name already exists
      /// </summary>
      /// <param name="tableName">name of table to create</param>
      /// <param name="columnFamilies">list of column family descriptors</param>
      public void createTable(byte[] tableName, List<ColumnDescriptor> columnFamilies)
      {
        #if !SILVERLIGHT
        send_createTable(tableName, columnFamilies);
        recv_createTable();

        #else
        var asyncResult = Begin_createTable(null, null, tableName, columnFamilies);
        End_createTable(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_createTable(AsyncCallback callback, object state, byte[] tableName, List<ColumnDescriptor> columnFamilies)
      #else
      public void send_createTable(byte[] tableName, List<ColumnDescriptor> columnFamilies)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("createTable", TMessageType.Call, seqid_));
        createTable_args args = new createTable_args();
        args.TableName = tableName;
        args.ColumnFamilies = columnFamilies;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public void recv_createTable()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        createTable_result result = new createTable_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.io) {
          throw result.Io;
        }
        if (result.__isset.ia) {
          throw result.Ia;
        }
        if (result.__isset.exist) {
          throw result.Exist;
        }
        return;
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_deleteTable(AsyncCallback callback, object state, byte[] tableName)
      {
        return send_deleteTable(callback, state, tableName);
      }

      public void End_deleteTable(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        recv_deleteTable();
      }

      #endif

      /// <summary>
      /// Deletes a table
      /// 
      /// @throws IOError if table doesn't exist on server or there was some other
      /// problem
      /// </summary>
      /// <param name="tableName">name of table to delete</param>
      public void deleteTable(byte[] tableName)
      {
        #if !SILVERLIGHT
        send_deleteTable(tableName);
        recv_deleteTable();

        #else
        var asyncResult = Begin_deleteTable(null, null, tableName);
        End_deleteTable(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_deleteTable(AsyncCallback callback, object state, byte[] tableName)
      #else
      public void send_deleteTable(byte[] tableName)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("deleteTable", TMessageType.Call, seqid_));
        deleteTable_args args = new deleteTable_args();
        args.TableName = tableName;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public void recv_deleteTable()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        deleteTable_result result = new deleteTable_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.io) {
          throw result.Io;
        }
        return;
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_get(AsyncCallback callback, object state, byte[] tableName, byte[] row, byte[] column, Dictionary<byte[], byte[]> attributes)
      {
        return send_get(callback, state, tableName, row, column, attributes);
      }

      public List<TCell> End_get(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_get();
      }

      #endif

      /// <summary>
      /// Get a single TCell for the specified table, row, and column at the
      /// latest timestamp. Returns an empty list if no such value exists.
      /// 
      /// @return value for specified row/column
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="row">row key</param>
      /// <param name="column">column name</param>
      /// <param name="attributes">Get attributes</param>
      public List<TCell> @get(byte[] tableName, byte[] row, byte[] column, Dictionary<byte[], byte[]> attributes)
      {
        #if !SILVERLIGHT
        send_get(tableName, row, column, attributes);
        return recv_get();

        #else
        var asyncResult = Begin_get(null, null, tableName, row, column, attributes);
        return End_get(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_get(AsyncCallback callback, object state, byte[] tableName, byte[] row, byte[] column, Dictionary<byte[], byte[]> attributes)
      #else
      public void send_get(byte[] tableName, byte[] row, byte[] column, Dictionary<byte[], byte[]> attributes)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("get", TMessageType.Call, seqid_));
        get_args args = new get_args();
        args.TableName = tableName;
        args.Row = row;
        args.Column = column;
        args.Attributes = attributes;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public List<TCell> recv_get()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        get_result result = new get_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.io) {
          throw result.Io;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "get failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_getVer(AsyncCallback callback, object state, byte[] tableName, byte[] row, byte[] column, int numVersions, Dictionary<byte[], byte[]> attributes)
      {
        return send_getVer(callback, state, tableName, row, column, numVersions, attributes);
      }

      public List<TCell> End_getVer(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_getVer();
      }

      #endif

      /// <summary>
      /// Get the specified number of versions for the specified table,
      /// row, and column.
      /// 
      /// @return list of cells for specified row/column
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="row">row key</param>
      /// <param name="column">column name</param>
      /// <param name="numVersions">number of versions to retrieve</param>
      /// <param name="attributes">Get attributes</param>
      public List<TCell> getVer(byte[] tableName, byte[] row, byte[] column, int numVersions, Dictionary<byte[], byte[]> attributes)
      {
        #if !SILVERLIGHT
        send_getVer(tableName, row, column, numVersions, attributes);
        return recv_getVer();

        #else
        var asyncResult = Begin_getVer(null, null, tableName, row, column, numVersions, attributes);
        return End_getVer(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_getVer(AsyncCallback callback, object state, byte[] tableName, byte[] row, byte[] column, int numVersions, Dictionary<byte[], byte[]> attributes)
      #else
      public void send_getVer(byte[] tableName, byte[] row, byte[] column, int numVersions, Dictionary<byte[], byte[]> attributes)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("getVer", TMessageType.Call, seqid_));
        getVer_args args = new getVer_args();
        args.TableName = tableName;
        args.Row = row;
        args.Column = column;
        args.NumVersions = numVersions;
        args.Attributes = attributes;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public List<TCell> recv_getVer()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        getVer_result result = new getVer_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.io) {
          throw result.Io;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getVer failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_getVerTs(AsyncCallback callback, object state, byte[] tableName, byte[] row, byte[] column, long timestamp, int numVersions, Dictionary<byte[], byte[]> attributes)
      {
        return send_getVerTs(callback, state, tableName, row, column, timestamp, numVersions, attributes);
      }

      public List<TCell> End_getVerTs(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_getVerTs();
      }

      #endif

      /// <summary>
      /// Get the specified number of versions for the specified table,
      /// row, and column.  Only versions less than or equal to the specified
      /// timestamp will be returned.
      /// 
      /// @return list of cells for specified row/column
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="row">row key</param>
      /// <param name="column">column name</param>
      /// <param name="timestamp">timestamp</param>
      /// <param name="numVersions">number of versions to retrieve</param>
      /// <param name="attributes">Get attributes</param>
      public List<TCell> getVerTs(byte[] tableName, byte[] row, byte[] column, long timestamp, int numVersions, Dictionary<byte[], byte[]> attributes)
      {
        #if !SILVERLIGHT
        send_getVerTs(tableName, row, column, timestamp, numVersions, attributes);
        return recv_getVerTs();

        #else
        var asyncResult = Begin_getVerTs(null, null, tableName, row, column, timestamp, numVersions, attributes);
        return End_getVerTs(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_getVerTs(AsyncCallback callback, object state, byte[] tableName, byte[] row, byte[] column, long timestamp, int numVersions, Dictionary<byte[], byte[]> attributes)
      #else
      public void send_getVerTs(byte[] tableName, byte[] row, byte[] column, long timestamp, int numVersions, Dictionary<byte[], byte[]> attributes)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("getVerTs", TMessageType.Call, seqid_));
        getVerTs_args args = new getVerTs_args();
        args.TableName = tableName;
        args.Row = row;
        args.Column = column;
        args.Timestamp = timestamp;
        args.NumVersions = numVersions;
        args.Attributes = attributes;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public List<TCell> recv_getVerTs()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        getVerTs_result result = new getVerTs_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.io) {
          throw result.Io;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getVerTs failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_getRow(AsyncCallback callback, object state, byte[] tableName, byte[] row, Dictionary<byte[], byte[]> attributes)
      {
        return send_getRow(callback, state, tableName, row, attributes);
      }

      public List<TRowResult> End_getRow(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_getRow();
      }

      #endif

      /// <summary>
      /// Get all the data for the specified table and row at the latest
      /// timestamp. Returns an empty list if the row does not exist.
      /// 
      /// @return TRowResult containing the row and map of columns to TCells
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="row">row key</param>
      /// <param name="attributes">Get attributes</param>
      public List<TRowResult> getRow(byte[] tableName, byte[] row, Dictionary<byte[], byte[]> attributes)
      {
        #if !SILVERLIGHT
        send_getRow(tableName, row, attributes);
        return recv_getRow();

        #else
        var asyncResult = Begin_getRow(null, null, tableName, row, attributes);
        return End_getRow(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_getRow(AsyncCallback callback, object state, byte[] tableName, byte[] row, Dictionary<byte[], byte[]> attributes)
      #else
      public void send_getRow(byte[] tableName, byte[] row, Dictionary<byte[], byte[]> attributes)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("getRow", TMessageType.Call, seqid_));
        getRow_args args = new getRow_args();
        args.TableName = tableName;
        args.Row = row;
        args.Attributes = attributes;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public List<TRowResult> recv_getRow()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        getRow_result result = new getRow_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.io) {
          throw result.Io;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getRow failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_getRowWithColumns(AsyncCallback callback, object state, byte[] tableName, byte[] row, List<byte[]> columns, Dictionary<byte[], byte[]> attributes)
      {
        return send_getRowWithColumns(callback, state, tableName, row, columns, attributes);
      }

      public List<TRowResult> End_getRowWithColumns(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_getRowWithColumns();
      }

      #endif

      /// <summary>
      /// Get the specified columns for the specified table and row at the latest
      /// timestamp. Returns an empty list if the row does not exist.
      /// 
      /// @return TRowResult containing the row and map of columns to TCells
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="row">row key</param>
      /// <param name="columns">List of columns to return, null for all columns</param>
      /// <param name="attributes">Get attributes</param>
      public List<TRowResult> getRowWithColumns(byte[] tableName, byte[] row, List<byte[]> columns, Dictionary<byte[], byte[]> attributes)
      {
        #if !SILVERLIGHT
        send_getRowWithColumns(tableName, row, columns, attributes);
        return recv_getRowWithColumns();

        #else
        var asyncResult = Begin_getRowWithColumns(null, null, tableName, row, columns, attributes);
        return End_getRowWithColumns(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_getRowWithColumns(AsyncCallback callback, object state, byte[] tableName, byte[] row, List<byte[]> columns, Dictionary<byte[], byte[]> attributes)
      #else
      public void send_getRowWithColumns(byte[] tableName, byte[] row, List<byte[]> columns, Dictionary<byte[], byte[]> attributes)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("getRowWithColumns", TMessageType.Call, seqid_));
        getRowWithColumns_args args = new getRowWithColumns_args();
        args.TableName = tableName;
        args.Row = row;
        args.Columns = columns;
        args.Attributes = attributes;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public List<TRowResult> recv_getRowWithColumns()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        getRowWithColumns_result result = new getRowWithColumns_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.io) {
          throw result.Io;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getRowWithColumns failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_getRowTs(AsyncCallback callback, object state, byte[] tableName, byte[] row, long timestamp, Dictionary<byte[], byte[]> attributes)
      {
        return send_getRowTs(callback, state, tableName, row, timestamp, attributes);
      }

      public List<TRowResult> End_getRowTs(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_getRowTs();
      }

      #endif

      /// <summary>
      /// Get all the data for the specified table and row at the specified
      /// timestamp. Returns an empty list if the row does not exist.
      /// 
      /// @return TRowResult containing the row and map of columns to TCells
      /// </summary>
      /// <param name="tableName">name of the table</param>
      /// <param name="row">row key</param>
      /// <param name="timestamp">timestamp</param>
      /// <param name="attributes">Get attributes</param>
      public List<TRowResult> getRowTs(byte[] tableName, byte[] row, long timestamp, Dictionary<byte[], byte[]> attributes)
      {
        #if !SILVERLIGHT
        send_getRowTs(tableName, row, timestamp, attributes);
        return recv_getRowTs();

        #else
        var asyncResult = Begin_getRowTs(null, null, tableName, row, timestamp, attributes);
        return End_getRowTs(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_getRowTs(AsyncCallback callback, object state, byte[] tableName, byte[] row, long timestamp, Dictionary<byte[], byte[]> attributes)
      #else
      public void send_getRowTs(byte[] tableName, byte[] row, long timestamp, Dictionary<byte[], byte[]> attributes)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("getRowTs", TMessageType.Call, seqid_));
        getRowTs_args args = new getRowTs_args();
        args.TableName = tableName;
        args.Row = row;
        args.Timestamp = timestamp;
        args.Attributes = attributes;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public List<TRowResult> recv_getRowTs()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        getRowTs_result result = new getRowTs_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.io) {
          throw result.Io;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getRowTs failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_getRowWithColumnsTs(AsyncCallback callback, object state, byte[] tableName, byte[] row, List<byte[]> columns, long timestamp, Dictionary<byte[], byte[]> attributes)
      {
        return send_getRowWithColumnsTs(callback, state, tableName, row, columns, timestamp, attributes);
      }

      public List<TRowResult> End_getRowWithColumnsTs(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_getRowWithColumnsTs();
      }

      #endif

      /// <summary>
      /// Get the specified columns for the specified table and row at the specified
      /// timestamp. Returns an empty list if the row does not exist.
      /// 
      /// @return TRowResult containing the row and map of columns to TCells
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="row">row key</param>
      /// <param name="columns">List of columns to return, null for all columns</param>
      /// <param name="timestamp"></param>
      /// <param name="attributes">Get attributes</param>
      public List<TRowResult> getRowWithColumnsTs(byte[] tableName, byte[] row, List<byte[]> columns, long timestamp, Dictionary<byte[], byte[]> attributes)
      {
        #if !SILVERLIGHT
        send_getRowWithColumnsTs(tableName, row, columns, timestamp, attributes);
        return recv_getRowWithColumnsTs();

        #else
        var asyncResult = Begin_getRowWithColumnsTs(null, null, tableName, row, columns, timestamp, attributes);
        return End_getRowWithColumnsTs(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_getRowWithColumnsTs(AsyncCallback callback, object state, byte[] tableName, byte[] row, List<byte[]> columns, long timestamp, Dictionary<byte[], byte[]> attributes)
      #else
      public void send_getRowWithColumnsTs(byte[] tableName, byte[] row, List<byte[]> columns, long timestamp, Dictionary<byte[], byte[]> attributes)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("getRowWithColumnsTs", TMessageType.Call, seqid_));
        getRowWithColumnsTs_args args = new getRowWithColumnsTs_args();
        args.TableName = tableName;
        args.Row = row;
        args.Columns = columns;
        args.Timestamp = timestamp;
        args.Attributes = attributes;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public List<TRowResult> recv_getRowWithColumnsTs()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        getRowWithColumnsTs_result result = new getRowWithColumnsTs_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.io) {
          throw result.Io;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getRowWithColumnsTs failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_getRows(AsyncCallback callback, object state, byte[] tableName, List<byte[]> rows, Dictionary<byte[], byte[]> attributes)
      {
        return send_getRows(callback, state, tableName, rows, attributes);
      }

      public List<TRowResult> End_getRows(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_getRows();
      }

      #endif

      /// <summary>
      /// Get all the data for the specified table and rows at the latest
      /// timestamp. Returns an empty list if no rows exist.
      /// 
      /// @return TRowResult containing the rows and map of columns to TCells
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="rows">row keys</param>
      /// <param name="attributes">Get attributes</param>
      public List<TRowResult> getRows(byte[] tableName, List<byte[]> rows, Dictionary<byte[], byte[]> attributes)
      {
        #if !SILVERLIGHT
        send_getRows(tableName, rows, attributes);
        return recv_getRows();

        #else
        var asyncResult = Begin_getRows(null, null, tableName, rows, attributes);
        return End_getRows(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_getRows(AsyncCallback callback, object state, byte[] tableName, List<byte[]> rows, Dictionary<byte[], byte[]> attributes)
      #else
      public void send_getRows(byte[] tableName, List<byte[]> rows, Dictionary<byte[], byte[]> attributes)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("getRows", TMessageType.Call, seqid_));
        getRows_args args = new getRows_args();
        args.TableName = tableName;
        args.Rows = rows;
        args.Attributes = attributes;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public List<TRowResult> recv_getRows()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        getRows_result result = new getRows_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.io) {
          throw result.Io;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getRows failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_getRowsWithColumns(AsyncCallback callback, object state, byte[] tableName, List<byte[]> rows, List<byte[]> columns, Dictionary<byte[], byte[]> attributes)
      {
        return send_getRowsWithColumns(callback, state, tableName, rows, columns, attributes);
      }

      public List<TRowResult> End_getRowsWithColumns(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_getRowsWithColumns();
      }

      #endif

      /// <summary>
      /// Get the specified columns for the specified table and rows at the latest
      /// timestamp. Returns an empty list if no rows exist.
      /// 
      /// @return TRowResult containing the rows and map of columns to TCells
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="rows">row keys</param>
      /// <param name="columns">List of columns to return, null for all columns</param>
      /// <param name="attributes">Get attributes</param>
      public List<TRowResult> getRowsWithColumns(byte[] tableName, List<byte[]> rows, List<byte[]> columns, Dictionary<byte[], byte[]> attributes)
      {
        #if !SILVERLIGHT
        send_getRowsWithColumns(tableName, rows, columns, attributes);
        return recv_getRowsWithColumns();

        #else
        var asyncResult = Begin_getRowsWithColumns(null, null, tableName, rows, columns, attributes);
        return End_getRowsWithColumns(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_getRowsWithColumns(AsyncCallback callback, object state, byte[] tableName, List<byte[]> rows, List<byte[]> columns, Dictionary<byte[], byte[]> attributes)
      #else
      public void send_getRowsWithColumns(byte[] tableName, List<byte[]> rows, List<byte[]> columns, Dictionary<byte[], byte[]> attributes)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("getRowsWithColumns", TMessageType.Call, seqid_));
        getRowsWithColumns_args args = new getRowsWithColumns_args();
        args.TableName = tableName;
        args.Rows = rows;
        args.Columns = columns;
        args.Attributes = attributes;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public List<TRowResult> recv_getRowsWithColumns()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        getRowsWithColumns_result result = new getRowsWithColumns_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.io) {
          throw result.Io;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getRowsWithColumns failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_getRowsTs(AsyncCallback callback, object state, byte[] tableName, List<byte[]> rows, long timestamp, Dictionary<byte[], byte[]> attributes)
      {
        return send_getRowsTs(callback, state, tableName, rows, timestamp, attributes);
      }

      public List<TRowResult> End_getRowsTs(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_getRowsTs();
      }

      #endif

      /// <summary>
      /// Get all the data for the specified table and rows at the specified
      /// timestamp. Returns an empty list if no rows exist.
      /// 
      /// @return TRowResult containing the rows and map of columns to TCells
      /// </summary>
      /// <param name="tableName">name of the table</param>
      /// <param name="rows">row keys</param>
      /// <param name="timestamp">timestamp</param>
      /// <param name="attributes">Get attributes</param>
      public List<TRowResult> getRowsTs(byte[] tableName, List<byte[]> rows, long timestamp, Dictionary<byte[], byte[]> attributes)
      {
        #if !SILVERLIGHT
        send_getRowsTs(tableName, rows, timestamp, attributes);
        return recv_getRowsTs();

        #else
        var asyncResult = Begin_getRowsTs(null, null, tableName, rows, timestamp, attributes);
        return End_getRowsTs(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_getRowsTs(AsyncCallback callback, object state, byte[] tableName, List<byte[]> rows, long timestamp, Dictionary<byte[], byte[]> attributes)
      #else
      public void send_getRowsTs(byte[] tableName, List<byte[]> rows, long timestamp, Dictionary<byte[], byte[]> attributes)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("getRowsTs", TMessageType.Call, seqid_));
        getRowsTs_args args = new getRowsTs_args();
        args.TableName = tableName;
        args.Rows = rows;
        args.Timestamp = timestamp;
        args.Attributes = attributes;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public List<TRowResult> recv_getRowsTs()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        getRowsTs_result result = new getRowsTs_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.io) {
          throw result.Io;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getRowsTs failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_getRowsWithColumnsTs(AsyncCallback callback, object state, byte[] tableName, List<byte[]> rows, List<byte[]> columns, long timestamp, Dictionary<byte[], byte[]> attributes)
      {
        return send_getRowsWithColumnsTs(callback, state, tableName, rows, columns, timestamp, attributes);
      }

      public List<TRowResult> End_getRowsWithColumnsTs(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_getRowsWithColumnsTs();
      }

      #endif

      /// <summary>
      /// Get the specified columns for the specified table and rows at the specified
      /// timestamp. Returns an empty list if no rows exist.
      /// 
      /// @return TRowResult containing the rows and map of columns to TCells
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="rows">row keys</param>
      /// <param name="columns">List of columns to return, null for all columns</param>
      /// <param name="timestamp"></param>
      /// <param name="attributes">Get attributes</param>
      public List<TRowResult> getRowsWithColumnsTs(byte[] tableName, List<byte[]> rows, List<byte[]> columns, long timestamp, Dictionary<byte[], byte[]> attributes)
      {
        #if !SILVERLIGHT
        send_getRowsWithColumnsTs(tableName, rows, columns, timestamp, attributes);
        return recv_getRowsWithColumnsTs();

        #else
        var asyncResult = Begin_getRowsWithColumnsTs(null, null, tableName, rows, columns, timestamp, attributes);
        return End_getRowsWithColumnsTs(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_getRowsWithColumnsTs(AsyncCallback callback, object state, byte[] tableName, List<byte[]> rows, List<byte[]> columns, long timestamp, Dictionary<byte[], byte[]> attributes)
      #else
      public void send_getRowsWithColumnsTs(byte[] tableName, List<byte[]> rows, List<byte[]> columns, long timestamp, Dictionary<byte[], byte[]> attributes)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("getRowsWithColumnsTs", TMessageType.Call, seqid_));
        getRowsWithColumnsTs_args args = new getRowsWithColumnsTs_args();
        args.TableName = tableName;
        args.Rows = rows;
        args.Columns = columns;
        args.Timestamp = timestamp;
        args.Attributes = attributes;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public List<TRowResult> recv_getRowsWithColumnsTs()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        getRowsWithColumnsTs_result result = new getRowsWithColumnsTs_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.io) {
          throw result.Io;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getRowsWithColumnsTs failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_mutateRow(AsyncCallback callback, object state, byte[] tableName, byte[] row, List<Mutation> mutations, Dictionary<byte[], byte[]> attributes)
      {
        return send_mutateRow(callback, state, tableName, row, mutations, attributes);
      }

      public void End_mutateRow(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        recv_mutateRow();
      }

      #endif

      /// <summary>
      /// Apply a series of mutations (updates/deletes) to a row in a
      /// single transaction.  If an exception is thrown, then the
      /// transaction is aborted.  Default current timestamp is used, and
      /// all entries will have an identical timestamp.
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="row">row key</param>
      /// <param name="mutations">list of mutation commands</param>
      /// <param name="attributes">Mutation attributes</param>
      public void mutateRow(byte[] tableName, byte[] row, List<Mutation> mutations, Dictionary<byte[], byte[]> attributes)
      {
        #if !SILVERLIGHT
        send_mutateRow(tableName, row, mutations, attributes);
        recv_mutateRow();

        #else
        var asyncResult = Begin_mutateRow(null, null, tableName, row, mutations, attributes);
        End_mutateRow(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_mutateRow(AsyncCallback callback, object state, byte[] tableName, byte[] row, List<Mutation> mutations, Dictionary<byte[], byte[]> attributes)
      #else
      public void send_mutateRow(byte[] tableName, byte[] row, List<Mutation> mutations, Dictionary<byte[], byte[]> attributes)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("mutateRow", TMessageType.Call, seqid_));
        mutateRow_args args = new mutateRow_args();
        args.TableName = tableName;
        args.Row = row;
        args.Mutations = mutations;
        args.Attributes = attributes;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public void recv_mutateRow()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        mutateRow_result result = new mutateRow_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.io) {
          throw result.Io;
        }
        if (result.__isset.ia) {
          throw result.Ia;
        }
        return;
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_mutateRowTs(AsyncCallback callback, object state, byte[] tableName, byte[] row, List<Mutation> mutations, long timestamp, Dictionary<byte[], byte[]> attributes)
      {
        return send_mutateRowTs(callback, state, tableName, row, mutations, timestamp, attributes);
      }

      public void End_mutateRowTs(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        recv_mutateRowTs();
      }

      #endif

      /// <summary>
      /// Apply a series of mutations (updates/deletes) to a row in a
      /// single transaction.  If an exception is thrown, then the
      /// transaction is aborted.  The specified timestamp is used, and
      /// all entries will have an identical timestamp.
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="row">row key</param>
      /// <param name="mutations">list of mutation commands</param>
      /// <param name="timestamp">timestamp</param>
      /// <param name="attributes">Mutation attributes</param>
      public void mutateRowTs(byte[] tableName, byte[] row, List<Mutation> mutations, long timestamp, Dictionary<byte[], byte[]> attributes)
      {
        #if !SILVERLIGHT
        send_mutateRowTs(tableName, row, mutations, timestamp, attributes);
        recv_mutateRowTs();

        #else
        var asyncResult = Begin_mutateRowTs(null, null, tableName, row, mutations, timestamp, attributes);
        End_mutateRowTs(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_mutateRowTs(AsyncCallback callback, object state, byte[] tableName, byte[] row, List<Mutation> mutations, long timestamp, Dictionary<byte[], byte[]> attributes)
      #else
      public void send_mutateRowTs(byte[] tableName, byte[] row, List<Mutation> mutations, long timestamp, Dictionary<byte[], byte[]> attributes)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("mutateRowTs", TMessageType.Call, seqid_));
        mutateRowTs_args args = new mutateRowTs_args();
        args.TableName = tableName;
        args.Row = row;
        args.Mutations = mutations;
        args.Timestamp = timestamp;
        args.Attributes = attributes;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public void recv_mutateRowTs()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        mutateRowTs_result result = new mutateRowTs_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.io) {
          throw result.Io;
        }
        if (result.__isset.ia) {
          throw result.Ia;
        }
        return;
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_mutateRows(AsyncCallback callback, object state, byte[] tableName, List<BatchMutation> rowBatches, Dictionary<byte[], byte[]> attributes)
      {
        return send_mutateRows(callback, state, tableName, rowBatches, attributes);
      }

      public void End_mutateRows(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        recv_mutateRows();
      }

      #endif

      /// <summary>
      /// Apply a series of batches (each a series of mutations on a single row)
      /// in a single transaction.  If an exception is thrown, then the
      /// transaction is aborted.  Default current timestamp is used, and
      /// all entries will have an identical timestamp.
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="rowBatches">list of row batches</param>
      /// <param name="attributes">Mutation attributes</param>
      public void mutateRows(byte[] tableName, List<BatchMutation> rowBatches, Dictionary<byte[], byte[]> attributes)
      {
        #if !SILVERLIGHT
        send_mutateRows(tableName, rowBatches, attributes);
        recv_mutateRows();

        #else
        var asyncResult = Begin_mutateRows(null, null, tableName, rowBatches, attributes);
        End_mutateRows(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_mutateRows(AsyncCallback callback, object state, byte[] tableName, List<BatchMutation> rowBatches, Dictionary<byte[], byte[]> attributes)
      #else
      public void send_mutateRows(byte[] tableName, List<BatchMutation> rowBatches, Dictionary<byte[], byte[]> attributes)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("mutateRows", TMessageType.Call, seqid_));
        mutateRows_args args = new mutateRows_args();
        args.TableName = tableName;
        args.RowBatches = rowBatches;
        args.Attributes = attributes;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public void recv_mutateRows()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        mutateRows_result result = new mutateRows_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.io) {
          throw result.Io;
        }
        if (result.__isset.ia) {
          throw result.Ia;
        }
        return;
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_mutateRowsTs(AsyncCallback callback, object state, byte[] tableName, List<BatchMutation> rowBatches, long timestamp, Dictionary<byte[], byte[]> attributes)
      {
        return send_mutateRowsTs(callback, state, tableName, rowBatches, timestamp, attributes);
      }

      public void End_mutateRowsTs(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        recv_mutateRowsTs();
      }

      #endif

      /// <summary>
      /// Apply a series of batches (each a series of mutations on a single row)
      /// in a single transaction.  If an exception is thrown, then the
      /// transaction is aborted.  The specified timestamp is used, and
      /// all entries will have an identical timestamp.
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="rowBatches">list of row batches</param>
      /// <param name="timestamp">timestamp</param>
      /// <param name="attributes">Mutation attributes</param>
      public void mutateRowsTs(byte[] tableName, List<BatchMutation> rowBatches, long timestamp, Dictionary<byte[], byte[]> attributes)
      {
        #if !SILVERLIGHT
        send_mutateRowsTs(tableName, rowBatches, timestamp, attributes);
        recv_mutateRowsTs();

        #else
        var asyncResult = Begin_mutateRowsTs(null, null, tableName, rowBatches, timestamp, attributes);
        End_mutateRowsTs(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_mutateRowsTs(AsyncCallback callback, object state, byte[] tableName, List<BatchMutation> rowBatches, long timestamp, Dictionary<byte[], byte[]> attributes)
      #else
      public void send_mutateRowsTs(byte[] tableName, List<BatchMutation> rowBatches, long timestamp, Dictionary<byte[], byte[]> attributes)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("mutateRowsTs", TMessageType.Call, seqid_));
        mutateRowsTs_args args = new mutateRowsTs_args();
        args.TableName = tableName;
        args.RowBatches = rowBatches;
        args.Timestamp = timestamp;
        args.Attributes = attributes;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public void recv_mutateRowsTs()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        mutateRowsTs_result result = new mutateRowsTs_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.io) {
          throw result.Io;
        }
        if (result.__isset.ia) {
          throw result.Ia;
        }
        return;
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_atomicIncrement(AsyncCallback callback, object state, byte[] tableName, byte[] row, byte[] column, long @value)
      {
        return send_atomicIncrement(callback, state, tableName, row, column, @value);
      }

      public long End_atomicIncrement(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_atomicIncrement();
      }

      #endif

      /// <summary>
      /// Atomically increment the column value specified.  Returns the next value post increment.
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="row">row to increment</param>
      /// <param name="column">name of column</param>
      /// <param name="value">amount to increment by</param>
      public long atomicIncrement(byte[] tableName, byte[] row, byte[] column, long @value)
      {
        #if !SILVERLIGHT
        send_atomicIncrement(tableName, row, column, @value);
        return recv_atomicIncrement();

        #else
        var asyncResult = Begin_atomicIncrement(null, null, tableName, row, column, @value);
        return End_atomicIncrement(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_atomicIncrement(AsyncCallback callback, object state, byte[] tableName, byte[] row, byte[] column, long @value)
      #else
      public void send_atomicIncrement(byte[] tableName, byte[] row, byte[] column, long @value)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("atomicIncrement", TMessageType.Call, seqid_));
        atomicIncrement_args args = new atomicIncrement_args();
        args.TableName = tableName;
        args.Row = row;
        args.Column = column;
        args.Value = @value;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public long recv_atomicIncrement()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        atomicIncrement_result result = new atomicIncrement_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.io) {
          throw result.Io;
        }
        if (result.__isset.ia) {
          throw result.Ia;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "atomicIncrement failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_deleteAll(AsyncCallback callback, object state, byte[] tableName, byte[] row, byte[] column, Dictionary<byte[], byte[]> attributes)
      {
        return send_deleteAll(callback, state, tableName, row, column, attributes);
      }

      public void End_deleteAll(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        recv_deleteAll();
      }

      #endif

      /// <summary>
      /// Delete all cells that match the passed row and column.
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="row">Row to update</param>
      /// <param name="column">name of column whose value is to be deleted</param>
      /// <param name="attributes">Delete attributes</param>
      public void deleteAll(byte[] tableName, byte[] row, byte[] column, Dictionary<byte[], byte[]> attributes)
      {
        #if !SILVERLIGHT
        send_deleteAll(tableName, row, column, attributes);
        recv_deleteAll();

        #else
        var asyncResult = Begin_deleteAll(null, null, tableName, row, column, attributes);
        End_deleteAll(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_deleteAll(AsyncCallback callback, object state, byte[] tableName, byte[] row, byte[] column, Dictionary<byte[], byte[]> attributes)
      #else
      public void send_deleteAll(byte[] tableName, byte[] row, byte[] column, Dictionary<byte[], byte[]> attributes)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("deleteAll", TMessageType.Call, seqid_));
        deleteAll_args args = new deleteAll_args();
        args.TableName = tableName;
        args.Row = row;
        args.Column = column;
        args.Attributes = attributes;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public void recv_deleteAll()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        deleteAll_result result = new deleteAll_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.io) {
          throw result.Io;
        }
        return;
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_deleteAllTs(AsyncCallback callback, object state, byte[] tableName, byte[] row, byte[] column, long timestamp, Dictionary<byte[], byte[]> attributes)
      {
        return send_deleteAllTs(callback, state, tableName, row, column, timestamp, attributes);
      }

      public void End_deleteAllTs(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        recv_deleteAllTs();
      }

      #endif

      /// <summary>
      /// Delete all cells that match the passed row and column and whose
      /// timestamp is equal-to or older than the passed timestamp.
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="row">Row to update</param>
      /// <param name="column">name of column whose value is to be deleted</param>
      /// <param name="timestamp">timestamp</param>
      /// <param name="attributes">Delete attributes</param>
      public void deleteAllTs(byte[] tableName, byte[] row, byte[] column, long timestamp, Dictionary<byte[], byte[]> attributes)
      {
        #if !SILVERLIGHT
        send_deleteAllTs(tableName, row, column, timestamp, attributes);
        recv_deleteAllTs();

        #else
        var asyncResult = Begin_deleteAllTs(null, null, tableName, row, column, timestamp, attributes);
        End_deleteAllTs(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_deleteAllTs(AsyncCallback callback, object state, byte[] tableName, byte[] row, byte[] column, long timestamp, Dictionary<byte[], byte[]> attributes)
      #else
      public void send_deleteAllTs(byte[] tableName, byte[] row, byte[] column, long timestamp, Dictionary<byte[], byte[]> attributes)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("deleteAllTs", TMessageType.Call, seqid_));
        deleteAllTs_args args = new deleteAllTs_args();
        args.TableName = tableName;
        args.Row = row;
        args.Column = column;
        args.Timestamp = timestamp;
        args.Attributes = attributes;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public void recv_deleteAllTs()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        deleteAllTs_result result = new deleteAllTs_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.io) {
          throw result.Io;
        }
        return;
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_deleteAllRow(AsyncCallback callback, object state, byte[] tableName, byte[] row, Dictionary<byte[], byte[]> attributes)
      {
        return send_deleteAllRow(callback, state, tableName, row, attributes);
      }

      public void End_deleteAllRow(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        recv_deleteAllRow();
      }

      #endif

      /// <summary>
      /// Completely delete the row's cells.
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="row">key of the row to be completely deleted.</param>
      /// <param name="attributes">Delete attributes</param>
      public void deleteAllRow(byte[] tableName, byte[] row, Dictionary<byte[], byte[]> attributes)
      {
        #if !SILVERLIGHT
        send_deleteAllRow(tableName, row, attributes);
        recv_deleteAllRow();

        #else
        var asyncResult = Begin_deleteAllRow(null, null, tableName, row, attributes);
        End_deleteAllRow(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_deleteAllRow(AsyncCallback callback, object state, byte[] tableName, byte[] row, Dictionary<byte[], byte[]> attributes)
      #else
      public void send_deleteAllRow(byte[] tableName, byte[] row, Dictionary<byte[], byte[]> attributes)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("deleteAllRow", TMessageType.Call, seqid_));
        deleteAllRow_args args = new deleteAllRow_args();
        args.TableName = tableName;
        args.Row = row;
        args.Attributes = attributes;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public void recv_deleteAllRow()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        deleteAllRow_result result = new deleteAllRow_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.io) {
          throw result.Io;
        }
        return;
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_increment(AsyncCallback callback, object state, TIncrement increment)
      {
        return send_increment(callback, state, increment);
      }

      public void End_increment(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        recv_increment();
      }

      #endif

      /// <summary>
      /// Increment a cell by the ammount.
      /// Increments can be applied async if hbase.regionserver.thrift.coalesceIncrement is set to true.
      /// False is the default.  Turn to true if you need the extra performance and can accept some
      /// data loss if a thrift server dies with increments still in the queue.
      /// </summary>
      /// <param name="increment">The single increment to apply</param>
      public void increment(TIncrement increment)
      {
        #if !SILVERLIGHT
        send_increment(increment);
        recv_increment();

        #else
        var asyncResult = Begin_increment(null, null, increment);
        End_increment(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_increment(AsyncCallback callback, object state, TIncrement increment)
      #else
      public void send_increment(TIncrement increment)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("increment", TMessageType.Call, seqid_));
        increment_args args = new increment_args();
        args.Increment = increment;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public void recv_increment()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        increment_result result = new increment_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.io) {
          throw result.Io;
        }
        return;
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_incrementRows(AsyncCallback callback, object state, List<TIncrement> increments)
      {
        return send_incrementRows(callback, state, increments);
      }

      public void End_incrementRows(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        recv_incrementRows();
      }

      #endif

      public void incrementRows(List<TIncrement> increments)
      {
        #if !SILVERLIGHT
        send_incrementRows(increments);
        recv_incrementRows();

        #else
        var asyncResult = Begin_incrementRows(null, null, increments);
        End_incrementRows(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_incrementRows(AsyncCallback callback, object state, List<TIncrement> increments)
      #else
      public void send_incrementRows(List<TIncrement> increments)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("incrementRows", TMessageType.Call, seqid_));
        incrementRows_args args = new incrementRows_args();
        args.Increments = increments;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public void recv_incrementRows()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        incrementRows_result result = new incrementRows_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.io) {
          throw result.Io;
        }
        return;
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_deleteAllRowTs(AsyncCallback callback, object state, byte[] tableName, byte[] row, long timestamp, Dictionary<byte[], byte[]> attributes)
      {
        return send_deleteAllRowTs(callback, state, tableName, row, timestamp, attributes);
      }

      public void End_deleteAllRowTs(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        recv_deleteAllRowTs();
      }

      #endif

      /// <summary>
      /// Completely delete the row's cells marked with a timestamp
      /// equal-to or older than the passed timestamp.
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="row">key of the row to be completely deleted.</param>
      /// <param name="timestamp">timestamp</param>
      /// <param name="attributes">Delete attributes</param>
      public void deleteAllRowTs(byte[] tableName, byte[] row, long timestamp, Dictionary<byte[], byte[]> attributes)
      {
        #if !SILVERLIGHT
        send_deleteAllRowTs(tableName, row, timestamp, attributes);
        recv_deleteAllRowTs();

        #else
        var asyncResult = Begin_deleteAllRowTs(null, null, tableName, row, timestamp, attributes);
        End_deleteAllRowTs(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_deleteAllRowTs(AsyncCallback callback, object state, byte[] tableName, byte[] row, long timestamp, Dictionary<byte[], byte[]> attributes)
      #else
      public void send_deleteAllRowTs(byte[] tableName, byte[] row, long timestamp, Dictionary<byte[], byte[]> attributes)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("deleteAllRowTs", TMessageType.Call, seqid_));
        deleteAllRowTs_args args = new deleteAllRowTs_args();
        args.TableName = tableName;
        args.Row = row;
        args.Timestamp = timestamp;
        args.Attributes = attributes;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public void recv_deleteAllRowTs()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        deleteAllRowTs_result result = new deleteAllRowTs_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.io) {
          throw result.Io;
        }
        return;
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_scannerOpenWithScan(AsyncCallback callback, object state, byte[] tableName, TScan scan, Dictionary<byte[], byte[]> attributes)
      {
        return send_scannerOpenWithScan(callback, state, tableName, scan, attributes);
      }

      public int End_scannerOpenWithScan(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_scannerOpenWithScan();
      }

      #endif

      /// <summary>
      /// Get a scanner on the current table, using the Scan instance
      /// for the scan parameters.
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="scan">Scan instance</param>
      /// <param name="attributes">Scan attributes</param>
      public int scannerOpenWithScan(byte[] tableName, TScan scan, Dictionary<byte[], byte[]> attributes)
      {
        #if !SILVERLIGHT
        send_scannerOpenWithScan(tableName, scan, attributes);
        return recv_scannerOpenWithScan();

        #else
        var asyncResult = Begin_scannerOpenWithScan(null, null, tableName, scan, attributes);
        return End_scannerOpenWithScan(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_scannerOpenWithScan(AsyncCallback callback, object state, byte[] tableName, TScan scan, Dictionary<byte[], byte[]> attributes)
      #else
      public void send_scannerOpenWithScan(byte[] tableName, TScan scan, Dictionary<byte[], byte[]> attributes)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("scannerOpenWithScan", TMessageType.Call, seqid_));
        scannerOpenWithScan_args args = new scannerOpenWithScan_args();
        args.TableName = tableName;
        args.Scan = scan;
        args.Attributes = attributes;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public int recv_scannerOpenWithScan()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        scannerOpenWithScan_result result = new scannerOpenWithScan_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.io) {
          throw result.Io;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "scannerOpenWithScan failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_scannerOpen(AsyncCallback callback, object state, byte[] tableName, byte[] startRow, List<byte[]> columns, Dictionary<byte[], byte[]> attributes)
      {
        return send_scannerOpen(callback, state, tableName, startRow, columns, attributes);
      }

      public int End_scannerOpen(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_scannerOpen();
      }

      #endif

      /// <summary>
      /// Get a scanner on the current table starting at the specified row and
      /// ending at the last row in the table.  Return the specified columns.
      /// 
      /// @return scanner id to be used with other scanner procedures
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="startRow">Starting row in table to scan.Send "" (empty string) to start at the first row.</param>
      /// <param name="columns">columns to scan. If column name is a column family, allcolumns of the specified column family are returned. It's also possibleto pass a regex in the column qualifier.</param>
      /// <param name="attributes">Scan attributes</param>
      public int scannerOpen(byte[] tableName, byte[] startRow, List<byte[]> columns, Dictionary<byte[], byte[]> attributes)
      {
        #if !SILVERLIGHT
        send_scannerOpen(tableName, startRow, columns, attributes);
        return recv_scannerOpen();

        #else
        var asyncResult = Begin_scannerOpen(null, null, tableName, startRow, columns, attributes);
        return End_scannerOpen(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_scannerOpen(AsyncCallback callback, object state, byte[] tableName, byte[] startRow, List<byte[]> columns, Dictionary<byte[], byte[]> attributes)
      #else
      public void send_scannerOpen(byte[] tableName, byte[] startRow, List<byte[]> columns, Dictionary<byte[], byte[]> attributes)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("scannerOpen", TMessageType.Call, seqid_));
        scannerOpen_args args = new scannerOpen_args();
        args.TableName = tableName;
        args.StartRow = startRow;
        args.Columns = columns;
        args.Attributes = attributes;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public int recv_scannerOpen()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        scannerOpen_result result = new scannerOpen_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.io) {
          throw result.Io;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "scannerOpen failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_scannerOpenWithStop(AsyncCallback callback, object state, byte[] tableName, byte[] startRow, byte[] stopRow, List<byte[]> columns, Dictionary<byte[], byte[]> attributes)
      {
        return send_scannerOpenWithStop(callback, state, tableName, startRow, stopRow, columns, attributes);
      }

      public int End_scannerOpenWithStop(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_scannerOpenWithStop();
      }

      #endif

      /// <summary>
      /// Get a scanner on the current table starting and stopping at the
      /// specified rows.  ending at the last row in the table.  Return the
      /// specified columns.
      /// 
      /// @return scanner id to be used with other scanner procedures
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="startRow">Starting row in table to scan.Send "" (empty string) to start at the first row.</param>
      /// <param name="stopRow">row to stop scanning on. This row is *not* included in thescanner's results</param>
      /// <param name="columns">columns to scan. If column name is a column family, allcolumns of the specified column family are returned. It's also possibleto pass a regex in the column qualifier.</param>
      /// <param name="attributes">Scan attributes</param>
      public int scannerOpenWithStop(byte[] tableName, byte[] startRow, byte[] stopRow, List<byte[]> columns, Dictionary<byte[], byte[]> attributes)
      {
        #if !SILVERLIGHT
        send_scannerOpenWithStop(tableName, startRow, stopRow, columns, attributes);
        return recv_scannerOpenWithStop();

        #else
        var asyncResult = Begin_scannerOpenWithStop(null, null, tableName, startRow, stopRow, columns, attributes);
        return End_scannerOpenWithStop(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_scannerOpenWithStop(AsyncCallback callback, object state, byte[] tableName, byte[] startRow, byte[] stopRow, List<byte[]> columns, Dictionary<byte[], byte[]> attributes)
      #else
      public void send_scannerOpenWithStop(byte[] tableName, byte[] startRow, byte[] stopRow, List<byte[]> columns, Dictionary<byte[], byte[]> attributes)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("scannerOpenWithStop", TMessageType.Call, seqid_));
        scannerOpenWithStop_args args = new scannerOpenWithStop_args();
        args.TableName = tableName;
        args.StartRow = startRow;
        args.StopRow = stopRow;
        args.Columns = columns;
        args.Attributes = attributes;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public int recv_scannerOpenWithStop()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        scannerOpenWithStop_result result = new scannerOpenWithStop_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.io) {
          throw result.Io;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "scannerOpenWithStop failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_scannerOpenWithPrefix(AsyncCallback callback, object state, byte[] tableName, byte[] startAndPrefix, List<byte[]> columns, Dictionary<byte[], byte[]> attributes)
      {
        return send_scannerOpenWithPrefix(callback, state, tableName, startAndPrefix, columns, attributes);
      }

      public int End_scannerOpenWithPrefix(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_scannerOpenWithPrefix();
      }

      #endif

      /// <summary>
      /// Open a scanner for a given prefix.  That is all rows will have the specified
      /// prefix. No other rows will be returned.
      /// 
      /// @return scanner id to use with other scanner calls
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="startAndPrefix">the prefix (and thus start row) of the keys you want</param>
      /// <param name="columns">the columns you want returned</param>
      /// <param name="attributes">Scan attributes</param>
      public int scannerOpenWithPrefix(byte[] tableName, byte[] startAndPrefix, List<byte[]> columns, Dictionary<byte[], byte[]> attributes)
      {
        #if !SILVERLIGHT
        send_scannerOpenWithPrefix(tableName, startAndPrefix, columns, attributes);
        return recv_scannerOpenWithPrefix();

        #else
        var asyncResult = Begin_scannerOpenWithPrefix(null, null, tableName, startAndPrefix, columns, attributes);
        return End_scannerOpenWithPrefix(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_scannerOpenWithPrefix(AsyncCallback callback, object state, byte[] tableName, byte[] startAndPrefix, List<byte[]> columns, Dictionary<byte[], byte[]> attributes)
      #else
      public void send_scannerOpenWithPrefix(byte[] tableName, byte[] startAndPrefix, List<byte[]> columns, Dictionary<byte[], byte[]> attributes)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("scannerOpenWithPrefix", TMessageType.Call, seqid_));
        scannerOpenWithPrefix_args args = new scannerOpenWithPrefix_args();
        args.TableName = tableName;
        args.StartAndPrefix = startAndPrefix;
        args.Columns = columns;
        args.Attributes = attributes;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public int recv_scannerOpenWithPrefix()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        scannerOpenWithPrefix_result result = new scannerOpenWithPrefix_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.io) {
          throw result.Io;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "scannerOpenWithPrefix failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_scannerOpenTs(AsyncCallback callback, object state, byte[] tableName, byte[] startRow, List<byte[]> columns, long timestamp, Dictionary<byte[], byte[]> attributes)
      {
        return send_scannerOpenTs(callback, state, tableName, startRow, columns, timestamp, attributes);
      }

      public int End_scannerOpenTs(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_scannerOpenTs();
      }

      #endif

      /// <summary>
      /// Get a scanner on the current table starting at the specified row and
      /// ending at the last row in the table.  Return the specified columns.
      /// Only values with the specified timestamp are returned.
      /// 
      /// @return scanner id to be used with other scanner procedures
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="startRow">Starting row in table to scan.Send "" (empty string) to start at the first row.</param>
      /// <param name="columns">columns to scan. If column name is a column family, allcolumns of the specified column family are returned. It's also possibleto pass a regex in the column qualifier.</param>
      /// <param name="timestamp">timestamp</param>
      /// <param name="attributes">Scan attributes</param>
      public int scannerOpenTs(byte[] tableName, byte[] startRow, List<byte[]> columns, long timestamp, Dictionary<byte[], byte[]> attributes)
      {
        #if !SILVERLIGHT
        send_scannerOpenTs(tableName, startRow, columns, timestamp, attributes);
        return recv_scannerOpenTs();

        #else
        var asyncResult = Begin_scannerOpenTs(null, null, tableName, startRow, columns, timestamp, attributes);
        return End_scannerOpenTs(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_scannerOpenTs(AsyncCallback callback, object state, byte[] tableName, byte[] startRow, List<byte[]> columns, long timestamp, Dictionary<byte[], byte[]> attributes)
      #else
      public void send_scannerOpenTs(byte[] tableName, byte[] startRow, List<byte[]> columns, long timestamp, Dictionary<byte[], byte[]> attributes)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("scannerOpenTs", TMessageType.Call, seqid_));
        scannerOpenTs_args args = new scannerOpenTs_args();
        args.TableName = tableName;
        args.StartRow = startRow;
        args.Columns = columns;
        args.Timestamp = timestamp;
        args.Attributes = attributes;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public int recv_scannerOpenTs()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        scannerOpenTs_result result = new scannerOpenTs_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.io) {
          throw result.Io;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "scannerOpenTs failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_scannerOpenWithStopTs(AsyncCallback callback, object state, byte[] tableName, byte[] startRow, byte[] stopRow, List<byte[]> columns, long timestamp, Dictionary<byte[], byte[]> attributes)
      {
        return send_scannerOpenWithStopTs(callback, state, tableName, startRow, stopRow, columns, timestamp, attributes);
      }

      public int End_scannerOpenWithStopTs(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_scannerOpenWithStopTs();
      }

      #endif

      /// <summary>
      /// Get a scanner on the current table starting and stopping at the
      /// specified rows.  ending at the last row in the table.  Return the
      /// specified columns.  Only values with the specified timestamp are
      /// returned.
      /// 
      /// @return scanner id to be used with other scanner procedures
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="startRow">Starting row in table to scan.Send "" (empty string) to start at the first row.</param>
      /// <param name="stopRow">row to stop scanning on. This row is *not* included in thescanner's results</param>
      /// <param name="columns">columns to scan. If column name is a column family, allcolumns of the specified column family are returned. It's also possibleto pass a regex in the column qualifier.</param>
      /// <param name="timestamp">timestamp</param>
      /// <param name="attributes">Scan attributes</param>
      public int scannerOpenWithStopTs(byte[] tableName, byte[] startRow, byte[] stopRow, List<byte[]> columns, long timestamp, Dictionary<byte[], byte[]> attributes)
      {
        #if !SILVERLIGHT
        send_scannerOpenWithStopTs(tableName, startRow, stopRow, columns, timestamp, attributes);
        return recv_scannerOpenWithStopTs();

        #else
        var asyncResult = Begin_scannerOpenWithStopTs(null, null, tableName, startRow, stopRow, columns, timestamp, attributes);
        return End_scannerOpenWithStopTs(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_scannerOpenWithStopTs(AsyncCallback callback, object state, byte[] tableName, byte[] startRow, byte[] stopRow, List<byte[]> columns, long timestamp, Dictionary<byte[], byte[]> attributes)
      #else
      public void send_scannerOpenWithStopTs(byte[] tableName, byte[] startRow, byte[] stopRow, List<byte[]> columns, long timestamp, Dictionary<byte[], byte[]> attributes)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("scannerOpenWithStopTs", TMessageType.Call, seqid_));
        scannerOpenWithStopTs_args args = new scannerOpenWithStopTs_args();
        args.TableName = tableName;
        args.StartRow = startRow;
        args.StopRow = stopRow;
        args.Columns = columns;
        args.Timestamp = timestamp;
        args.Attributes = attributes;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public int recv_scannerOpenWithStopTs()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        scannerOpenWithStopTs_result result = new scannerOpenWithStopTs_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.io) {
          throw result.Io;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "scannerOpenWithStopTs failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_scannerGet(AsyncCallback callback, object state, int id)
      {
        return send_scannerGet(callback, state, id);
      }

      public List<TRowResult> End_scannerGet(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_scannerGet();
      }

      #endif

      /// <summary>
      /// Returns the scanner's current row value and advances to the next
      /// row in the table.  When there are no more rows in the table, or a key
      /// greater-than-or-equal-to the scanner's specified stopRow is reached,
      /// an empty list is returned.
      /// 
      /// @return a TRowResult containing the current row and a map of the columns to TCells.
      /// 
      /// @throws IllegalArgument if ScannerID is invalid
      /// 
      /// @throws NotFound when the scanner reaches the end
      /// </summary>
      /// <param name="id">id of a scanner returned by scannerOpen</param>
      public List<TRowResult> scannerGet(int id)
      {
        #if !SILVERLIGHT
        send_scannerGet(id);
        return recv_scannerGet();

        #else
        var asyncResult = Begin_scannerGet(null, null, id);
        return End_scannerGet(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_scannerGet(AsyncCallback callback, object state, int id)
      #else
      public void send_scannerGet(int id)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("scannerGet", TMessageType.Call, seqid_));
        scannerGet_args args = new scannerGet_args();
        args.Id = id;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public List<TRowResult> recv_scannerGet()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        scannerGet_result result = new scannerGet_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.io) {
          throw result.Io;
        }
        if (result.__isset.ia) {
          throw result.Ia;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "scannerGet failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_scannerGetList(AsyncCallback callback, object state, int id, int nbRows)
      {
        return send_scannerGetList(callback, state, id, nbRows);
      }

      public List<TRowResult> End_scannerGetList(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_scannerGetList();
      }

      #endif

      /// <summary>
      /// Returns, starting at the scanner's current row value nbRows worth of
      /// rows and advances to the next row in the table.  When there are no more
      /// rows in the table, or a key greater-than-or-equal-to the scanner's
      /// specified stopRow is reached,  an empty list is returned.
      /// 
      /// @return a TRowResult containing the current row and a map of the columns to TCells.
      /// 
      /// @throws IllegalArgument if ScannerID is invalid
      /// 
      /// @throws NotFound when the scanner reaches the end
      /// </summary>
      /// <param name="id">id of a scanner returned by scannerOpen</param>
      /// <param name="nbRows">number of results to return</param>
      public List<TRowResult> scannerGetList(int id, int nbRows)
      {
        #if !SILVERLIGHT
        send_scannerGetList(id, nbRows);
        return recv_scannerGetList();

        #else
        var asyncResult = Begin_scannerGetList(null, null, id, nbRows);
        return End_scannerGetList(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_scannerGetList(AsyncCallback callback, object state, int id, int nbRows)
      #else
      public void send_scannerGetList(int id, int nbRows)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("scannerGetList", TMessageType.Call, seqid_));
        scannerGetList_args args = new scannerGetList_args();
        args.Id = id;
        args.NbRows = nbRows;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public List<TRowResult> recv_scannerGetList()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        scannerGetList_result result = new scannerGetList_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.io) {
          throw result.Io;
        }
        if (result.__isset.ia) {
          throw result.Ia;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "scannerGetList failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_scannerClose(AsyncCallback callback, object state, int id)
      {
        return send_scannerClose(callback, state, id);
      }

      public void End_scannerClose(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        recv_scannerClose();
      }

      #endif

      /// <summary>
      /// Closes the server-state associated with an open scanner.
      /// 
      /// @throws IllegalArgument if ScannerID is invalid
      /// </summary>
      /// <param name="id">id of a scanner returned by scannerOpen</param>
      public void scannerClose(int id)
      {
        #if !SILVERLIGHT
        send_scannerClose(id);
        recv_scannerClose();

        #else
        var asyncResult = Begin_scannerClose(null, null, id);
        End_scannerClose(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_scannerClose(AsyncCallback callback, object state, int id)
      #else
      public void send_scannerClose(int id)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("scannerClose", TMessageType.Call, seqid_));
        scannerClose_args args = new scannerClose_args();
        args.Id = id;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public void recv_scannerClose()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        scannerClose_result result = new scannerClose_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.io) {
          throw result.Io;
        }
        if (result.__isset.ia) {
          throw result.Ia;
        }
        return;
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_getRowOrBefore(AsyncCallback callback, object state, byte[] tableName, byte[] row, byte[] family)
      {
        return send_getRowOrBefore(callback, state, tableName, row, family);
      }

      public List<TCell> End_getRowOrBefore(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_getRowOrBefore();
      }

      #endif

      /// <summary>
      /// Get the row just before the specified one.
      /// 
      /// @return value for specified row/column
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="row">row key</param>
      /// <param name="family">column name</param>
      public List<TCell> getRowOrBefore(byte[] tableName, byte[] row, byte[] family)
      {
        #if !SILVERLIGHT
        send_getRowOrBefore(tableName, row, family);
        return recv_getRowOrBefore();

        #else
        var asyncResult = Begin_getRowOrBefore(null, null, tableName, row, family);
        return End_getRowOrBefore(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_getRowOrBefore(AsyncCallback callback, object state, byte[] tableName, byte[] row, byte[] family)
      #else
      public void send_getRowOrBefore(byte[] tableName, byte[] row, byte[] family)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("getRowOrBefore", TMessageType.Call, seqid_));
        getRowOrBefore_args args = new getRowOrBefore_args();
        args.TableName = tableName;
        args.Row = row;
        args.Family = family;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public List<TCell> recv_getRowOrBefore()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        getRowOrBefore_result result = new getRowOrBefore_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.io) {
          throw result.Io;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getRowOrBefore failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_getRegionInfo(AsyncCallback callback, object state, byte[] row)
      {
        return send_getRegionInfo(callback, state, row);
      }

      public TRegionInfo End_getRegionInfo(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_getRegionInfo();
      }

      #endif

      /// <summary>
      /// Get the regininfo for the specified row. It scans
      /// the metatable to find region's start and end keys.
      /// 
      /// @return value for specified row/column
      /// </summary>
      /// <param name="row">row key</param>
      public TRegionInfo getRegionInfo(byte[] row)
      {
        #if !SILVERLIGHT
        send_getRegionInfo(row);
        return recv_getRegionInfo();

        #else
        var asyncResult = Begin_getRegionInfo(null, null, row);
        return End_getRegionInfo(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_getRegionInfo(AsyncCallback callback, object state, byte[] row)
      #else
      public void send_getRegionInfo(byte[] row)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("getRegionInfo", TMessageType.Call, seqid_));
        getRegionInfo_args args = new getRegionInfo_args();
        args.Row = row;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public TRegionInfo recv_getRegionInfo()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        getRegionInfo_result result = new getRegionInfo_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.io) {
          throw result.Io;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getRegionInfo failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_append(AsyncCallback callback, object state, TAppend append)
      {
        return send_append(callback, state, append);
      }

      public List<TCell> End_append(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_append();
      }

      #endif

      /// <summary>
      /// Appends values to one or more columns within a single row.
      /// 
      /// @return values of columns after the append operation.
      /// </summary>
      /// <param name="append">The single append operation to apply</param>
      public List<TCell> append(TAppend append)
      {
        #if !SILVERLIGHT
        send_append(append);
        return recv_append();

        #else
        var asyncResult = Begin_append(null, null, append);
        return End_append(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_append(AsyncCallback callback, object state, TAppend append)
      #else
      public void send_append(TAppend append)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("append", TMessageType.Call, seqid_));
        append_args args = new append_args();
        args.Append = append;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public List<TCell> recv_append()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        append_result result = new append_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.io) {
          throw result.Io;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "append failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_checkAndPut(AsyncCallback callback, object state, byte[] tableName, byte[] row, byte[] column, byte[] @value, Mutation mput, Dictionary<byte[], byte[]> attributes)
      {
        return send_checkAndPut(callback, state, tableName, row, column, @value, mput, attributes);
      }

      public bool End_checkAndPut(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_checkAndPut();
      }

      #endif

      /// <summary>
      /// Atomically checks if a row/family/qualifier value matches the expected
      /// value. If it does, it adds the corresponding mutation operation for put.
      /// 
      /// @return true if the new put was executed, false otherwise
      /// </summary>
      /// <param name="tableName">name of table</param>
      /// <param name="row">row key</param>
      /// <param name="column">column name</param>
      /// <param name="value">the expected value for the column parameter, if notprovided the check is for the non-existence of thecolumn in question</param>
      /// <param name="mput">mutation for the put</param>
      /// <param name="attributes">Mutation attributes</param>
      public bool checkAndPut(byte[] tableName, byte[] row, byte[] column, byte[] @value, Mutation mput, Dictionary<byte[], byte[]> attributes)
      {
        #if !SILVERLIGHT
        send_checkAndPut(tableName, row, column, @value, mput, attributes);
        return recv_checkAndPut();

        #else
        var asyncResult = Begin_checkAndPut(null, null, tableName, row, column, @value, mput, attributes);
        return End_checkAndPut(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_checkAndPut(AsyncCallback callback, object state, byte[] tableName, byte[] row, byte[] column, byte[] @value, Mutation mput, Dictionary<byte[], byte[]> attributes)
      #else
      public void send_checkAndPut(byte[] tableName, byte[] row, byte[] column, byte[] @value, Mutation mput, Dictionary<byte[], byte[]> attributes)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("checkAndPut", TMessageType.Call, seqid_));
        checkAndPut_args args = new checkAndPut_args();
        args.TableName = tableName;
        args.Row = row;
        args.Column = column;
        args.Value = @value;
        args.Mput = mput;
        args.Attributes = attributes;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public bool recv_checkAndPut()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        checkAndPut_result result = new checkAndPut_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.io) {
          throw result.Io;
        }
        if (result.__isset.ia) {
          throw result.Ia;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "checkAndPut failed: unknown result");
      }

    }
    public class Processor : TProcessor {
      public Processor(ISync iface)
      {
        iface_ = iface;
        processMap_["enableTable"] = enableTable_Process;
        processMap_["disableTable"] = disableTable_Process;
        processMap_["isTableEnabled"] = isTableEnabled_Process;
        processMap_["compact"] = compact_Process;
        processMap_["majorCompact"] = majorCompact_Process;
        processMap_["getTableNames"] = getTableNames_Process;
        processMap_["getColumnDescriptors"] = getColumnDescriptors_Process;
        processMap_["getTableRegions"] = getTableRegions_Process;
        processMap_["createTable"] = createTable_Process;
        processMap_["deleteTable"] = deleteTable_Process;
        processMap_["get"] = get_Process;
        processMap_["getVer"] = getVer_Process;
        processMap_["getVerTs"] = getVerTs_Process;
        processMap_["getRow"] = getRow_Process;
        processMap_["getRowWithColumns"] = getRowWithColumns_Process;
        processMap_["getRowTs"] = getRowTs_Process;
        processMap_["getRowWithColumnsTs"] = getRowWithColumnsTs_Process;
        processMap_["getRows"] = getRows_Process;
        processMap_["getRowsWithColumns"] = getRowsWithColumns_Process;
        processMap_["getRowsTs"] = getRowsTs_Process;
        processMap_["getRowsWithColumnsTs"] = getRowsWithColumnsTs_Process;
        processMap_["mutateRow"] = mutateRow_Process;
        processMap_["mutateRowTs"] = mutateRowTs_Process;
        processMap_["mutateRows"] = mutateRows_Process;
        processMap_["mutateRowsTs"] = mutateRowsTs_Process;
        processMap_["atomicIncrement"] = atomicIncrement_Process;
        processMap_["deleteAll"] = deleteAll_Process;
        processMap_["deleteAllTs"] = deleteAllTs_Process;
        processMap_["deleteAllRow"] = deleteAllRow_Process;
        processMap_["increment"] = increment_Process;
        processMap_["incrementRows"] = incrementRows_Process;
        processMap_["deleteAllRowTs"] = deleteAllRowTs_Process;
        processMap_["scannerOpenWithScan"] = scannerOpenWithScan_Process;
        processMap_["scannerOpen"] = scannerOpen_Process;
        processMap_["scannerOpenWithStop"] = scannerOpenWithStop_Process;
        processMap_["scannerOpenWithPrefix"] = scannerOpenWithPrefix_Process;
        processMap_["scannerOpenTs"] = scannerOpenTs_Process;
        processMap_["scannerOpenWithStopTs"] = scannerOpenWithStopTs_Process;
        processMap_["scannerGet"] = scannerGet_Process;
        processMap_["scannerGetList"] = scannerGetList_Process;
        processMap_["scannerClose"] = scannerClose_Process;
        processMap_["getRowOrBefore"] = getRowOrBefore_Process;
        processMap_["getRegionInfo"] = getRegionInfo_Process;
        processMap_["append"] = append_Process;
        processMap_["checkAndPut"] = checkAndPut_Process;
      }

      protected delegate void ProcessFunction(int seqid, TProtocol iprot, TProtocol oprot);
      private ISync iface_;
      protected Dictionary<string, ProcessFunction> processMap_ = new Dictionary<string, ProcessFunction>();

      public bool Process(TProtocol iprot, TProtocol oprot)
      {
        try
        {
          TMessage msg = iprot.ReadMessageBegin();
          ProcessFunction fn;
          processMap_.TryGetValue(msg.Name, out fn);
          if (fn == null) {
            TProtocolUtil.Skip(iprot, TType.Struct);
            iprot.ReadMessageEnd();
            TApplicationException x = new TApplicationException (TApplicationException.ExceptionType.UnknownMethod, "Invalid method name: '" + msg.Name + "'");
            oprot.WriteMessageBegin(new TMessage(msg.Name, TMessageType.Exception, msg.SeqID));
            x.Write(oprot);
            oprot.WriteMessageEnd();
            oprot.Transport.Flush();
            return true;
          }
          fn(msg.SeqID, iprot, oprot);
        }
        catch (IOException)
        {
          return false;
        }
        return true;
      }

      public void enableTable_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        enableTable_args args = new enableTable_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        enableTable_result result = new enableTable_result();
        try
        {
          try
          {
            iface_.enableTable(args.TableName);
          }
          catch (IOError io)
          {
            result.Io = io;
          }
          oprot.WriteMessageBegin(new TMessage("enableTable", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("enableTable", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void disableTable_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        disableTable_args args = new disableTable_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        disableTable_result result = new disableTable_result();
        try
        {
          try
          {
            iface_.disableTable(args.TableName);
          }
          catch (IOError io)
          {
            result.Io = io;
          }
          oprot.WriteMessageBegin(new TMessage("disableTable", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("disableTable", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void isTableEnabled_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        isTableEnabled_args args = new isTableEnabled_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        isTableEnabled_result result = new isTableEnabled_result();
        try
        {
          try
          {
            result.Success = iface_.isTableEnabled(args.TableName);
          }
          catch (IOError io)
          {
            result.Io = io;
          }
          oprot.WriteMessageBegin(new TMessage("isTableEnabled", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("isTableEnabled", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void compact_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        compact_args args = new compact_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        compact_result result = new compact_result();
        try
        {
          try
          {
            iface_.compact(args.TableNameOrRegionName);
          }
          catch (IOError io)
          {
            result.Io = io;
          }
          oprot.WriteMessageBegin(new TMessage("compact", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("compact", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void majorCompact_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        majorCompact_args args = new majorCompact_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        majorCompact_result result = new majorCompact_result();
        try
        {
          try
          {
            iface_.majorCompact(args.TableNameOrRegionName);
          }
          catch (IOError io)
          {
            result.Io = io;
          }
          oprot.WriteMessageBegin(new TMessage("majorCompact", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("majorCompact", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void getTableNames_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        getTableNames_args args = new getTableNames_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        getTableNames_result result = new getTableNames_result();
        try
        {
          try
          {
            result.Success = iface_.getTableNames();
          }
          catch (IOError io)
          {
            result.Io = io;
          }
          oprot.WriteMessageBegin(new TMessage("getTableNames", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("getTableNames", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void getColumnDescriptors_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        getColumnDescriptors_args args = new getColumnDescriptors_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        getColumnDescriptors_result result = new getColumnDescriptors_result();
        try
        {
          try
          {
            result.Success = iface_.getColumnDescriptors(args.TableName);
          }
          catch (IOError io)
          {
            result.Io = io;
          }
          oprot.WriteMessageBegin(new TMessage("getColumnDescriptors", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("getColumnDescriptors", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void getTableRegions_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        getTableRegions_args args = new getTableRegions_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        getTableRegions_result result = new getTableRegions_result();
        try
        {
          try
          {
            result.Success = iface_.getTableRegions(args.TableName);
          }
          catch (IOError io)
          {
            result.Io = io;
          }
          oprot.WriteMessageBegin(new TMessage("getTableRegions", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("getTableRegions", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void createTable_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        createTable_args args = new createTable_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        createTable_result result = new createTable_result();
        try
        {
          try
          {
            iface_.createTable(args.TableName, args.ColumnFamilies);
          }
          catch (IOError io)
          {
            result.Io = io;
          }
          catch (IllegalArgument ia)
          {
            result.Ia = ia;
          }
          catch (AlreadyExists exist)
          {
            result.Exist = exist;
          }
          oprot.WriteMessageBegin(new TMessage("createTable", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("createTable", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void deleteTable_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        deleteTable_args args = new deleteTable_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        deleteTable_result result = new deleteTable_result();
        try
        {
          try
          {
            iface_.deleteTable(args.TableName);
          }
          catch (IOError io)
          {
            result.Io = io;
          }
          oprot.WriteMessageBegin(new TMessage("deleteTable", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("deleteTable", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void get_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        get_args args = new get_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        get_result result = new get_result();
        try
        {
          try
          {
            result.Success = iface_.@get(args.TableName, args.Row, args.Column, args.Attributes);
          }
          catch (IOError io)
          {
            result.Io = io;
          }
          oprot.WriteMessageBegin(new TMessage("get", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("get", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void getVer_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        getVer_args args = new getVer_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        getVer_result result = new getVer_result();
        try
        {
          try
          {
            result.Success = iface_.getVer(args.TableName, args.Row, args.Column, args.NumVersions, args.Attributes);
          }
          catch (IOError io)
          {
            result.Io = io;
          }
          oprot.WriteMessageBegin(new TMessage("getVer", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("getVer", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void getVerTs_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        getVerTs_args args = new getVerTs_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        getVerTs_result result = new getVerTs_result();
        try
        {
          try
          {
            result.Success = iface_.getVerTs(args.TableName, args.Row, args.Column, args.Timestamp, args.NumVersions, args.Attributes);
          }
          catch (IOError io)
          {
            result.Io = io;
          }
          oprot.WriteMessageBegin(new TMessage("getVerTs", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("getVerTs", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void getRow_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        getRow_args args = new getRow_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        getRow_result result = new getRow_result();
        try
        {
          try
          {
            result.Success = iface_.getRow(args.TableName, args.Row, args.Attributes);
          }
          catch (IOError io)
          {
            result.Io = io;
          }
          oprot.WriteMessageBegin(new TMessage("getRow", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("getRow", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void getRowWithColumns_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        getRowWithColumns_args args = new getRowWithColumns_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        getRowWithColumns_result result = new getRowWithColumns_result();
        try
        {
          try
          {
            result.Success = iface_.getRowWithColumns(args.TableName, args.Row, args.Columns, args.Attributes);
          }
          catch (IOError io)
          {
            result.Io = io;
          }
          oprot.WriteMessageBegin(new TMessage("getRowWithColumns", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("getRowWithColumns", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void getRowTs_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        getRowTs_args args = new getRowTs_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        getRowTs_result result = new getRowTs_result();
        try
        {
          try
          {
            result.Success = iface_.getRowTs(args.TableName, args.Row, args.Timestamp, args.Attributes);
          }
          catch (IOError io)
          {
            result.Io = io;
          }
          oprot.WriteMessageBegin(new TMessage("getRowTs", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("getRowTs", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void getRowWithColumnsTs_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        getRowWithColumnsTs_args args = new getRowWithColumnsTs_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        getRowWithColumnsTs_result result = new getRowWithColumnsTs_result();
        try
        {
          try
          {
            result.Success = iface_.getRowWithColumnsTs(args.TableName, args.Row, args.Columns, args.Timestamp, args.Attributes);
          }
          catch (IOError io)
          {
            result.Io = io;
          }
          oprot.WriteMessageBegin(new TMessage("getRowWithColumnsTs", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("getRowWithColumnsTs", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void getRows_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        getRows_args args = new getRows_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        getRows_result result = new getRows_result();
        try
        {
          try
          {
            result.Success = iface_.getRows(args.TableName, args.Rows, args.Attributes);
          }
          catch (IOError io)
          {
            result.Io = io;
          }
          oprot.WriteMessageBegin(new TMessage("getRows", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("getRows", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void getRowsWithColumns_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        getRowsWithColumns_args args = new getRowsWithColumns_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        getRowsWithColumns_result result = new getRowsWithColumns_result();
        try
        {
          try
          {
            result.Success = iface_.getRowsWithColumns(args.TableName, args.Rows, args.Columns, args.Attributes);
          }
          catch (IOError io)
          {
            result.Io = io;
          }
          oprot.WriteMessageBegin(new TMessage("getRowsWithColumns", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("getRowsWithColumns", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void getRowsTs_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        getRowsTs_args args = new getRowsTs_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        getRowsTs_result result = new getRowsTs_result();
        try
        {
          try
          {
            result.Success = iface_.getRowsTs(args.TableName, args.Rows, args.Timestamp, args.Attributes);
          }
          catch (IOError io)
          {
            result.Io = io;
          }
          oprot.WriteMessageBegin(new TMessage("getRowsTs", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("getRowsTs", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void getRowsWithColumnsTs_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        getRowsWithColumnsTs_args args = new getRowsWithColumnsTs_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        getRowsWithColumnsTs_result result = new getRowsWithColumnsTs_result();
        try
        {
          try
          {
            result.Success = iface_.getRowsWithColumnsTs(args.TableName, args.Rows, args.Columns, args.Timestamp, args.Attributes);
          }
          catch (IOError io)
          {
            result.Io = io;
          }
          oprot.WriteMessageBegin(new TMessage("getRowsWithColumnsTs", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("getRowsWithColumnsTs", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void mutateRow_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        mutateRow_args args = new mutateRow_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        mutateRow_result result = new mutateRow_result();
        try
        {
          try
          {
            iface_.mutateRow(args.TableName, args.Row, args.Mutations, args.Attributes);
          }
          catch (IOError io)
          {
            result.Io = io;
          }
          catch (IllegalArgument ia)
          {
            result.Ia = ia;
          }
          oprot.WriteMessageBegin(new TMessage("mutateRow", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("mutateRow", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void mutateRowTs_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        mutateRowTs_args args = new mutateRowTs_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        mutateRowTs_result result = new mutateRowTs_result();
        try
        {
          try
          {
            iface_.mutateRowTs(args.TableName, args.Row, args.Mutations, args.Timestamp, args.Attributes);
          }
          catch (IOError io)
          {
            result.Io = io;
          }
          catch (IllegalArgument ia)
          {
            result.Ia = ia;
          }
          oprot.WriteMessageBegin(new TMessage("mutateRowTs", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("mutateRowTs", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void mutateRows_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        mutateRows_args args = new mutateRows_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        mutateRows_result result = new mutateRows_result();
        try
        {
          try
          {
            iface_.mutateRows(args.TableName, args.RowBatches, args.Attributes);
          }
          catch (IOError io)
          {
            result.Io = io;
          }
          catch (IllegalArgument ia)
          {
            result.Ia = ia;
          }
          oprot.WriteMessageBegin(new TMessage("mutateRows", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("mutateRows", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void mutateRowsTs_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        mutateRowsTs_args args = new mutateRowsTs_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        mutateRowsTs_result result = new mutateRowsTs_result();
        try
        {
          try
          {
            iface_.mutateRowsTs(args.TableName, args.RowBatches, args.Timestamp, args.Attributes);
          }
          catch (IOError io)
          {
            result.Io = io;
          }
          catch (IllegalArgument ia)
          {
            result.Ia = ia;
          }
          oprot.WriteMessageBegin(new TMessage("mutateRowsTs", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("mutateRowsTs", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void atomicIncrement_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        atomicIncrement_args args = new atomicIncrement_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        atomicIncrement_result result = new atomicIncrement_result();
        try
        {
          try
          {
            result.Success = iface_.atomicIncrement(args.TableName, args.Row, args.Column, args.Value);
          }
          catch (IOError io)
          {
            result.Io = io;
          }
          catch (IllegalArgument ia)
          {
            result.Ia = ia;
          }
          oprot.WriteMessageBegin(new TMessage("atomicIncrement", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("atomicIncrement", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void deleteAll_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        deleteAll_args args = new deleteAll_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        deleteAll_result result = new deleteAll_result();
        try
        {
          try
          {
            iface_.deleteAll(args.TableName, args.Row, args.Column, args.Attributes);
          }
          catch (IOError io)
          {
            result.Io = io;
          }
          oprot.WriteMessageBegin(new TMessage("deleteAll", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("deleteAll", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void deleteAllTs_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        deleteAllTs_args args = new deleteAllTs_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        deleteAllTs_result result = new deleteAllTs_result();
        try
        {
          try
          {
            iface_.deleteAllTs(args.TableName, args.Row, args.Column, args.Timestamp, args.Attributes);
          }
          catch (IOError io)
          {
            result.Io = io;
          }
          oprot.WriteMessageBegin(new TMessage("deleteAllTs", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("deleteAllTs", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void deleteAllRow_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        deleteAllRow_args args = new deleteAllRow_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        deleteAllRow_result result = new deleteAllRow_result();
        try
        {
          try
          {
            iface_.deleteAllRow(args.TableName, args.Row, args.Attributes);
          }
          catch (IOError io)
          {
            result.Io = io;
          }
          oprot.WriteMessageBegin(new TMessage("deleteAllRow", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("deleteAllRow", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void increment_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        increment_args args = new increment_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        increment_result result = new increment_result();
        try
        {
          try
          {
            iface_.increment(args.Increment);
          }
          catch (IOError io)
          {
            result.Io = io;
          }
          oprot.WriteMessageBegin(new TMessage("increment", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("increment", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void incrementRows_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        incrementRows_args args = new incrementRows_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        incrementRows_result result = new incrementRows_result();
        try
        {
          try
          {
            iface_.incrementRows(args.Increments);
          }
          catch (IOError io)
          {
            result.Io = io;
          }
          oprot.WriteMessageBegin(new TMessage("incrementRows", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("incrementRows", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void deleteAllRowTs_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        deleteAllRowTs_args args = new deleteAllRowTs_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        deleteAllRowTs_result result = new deleteAllRowTs_result();
        try
        {
          try
          {
            iface_.deleteAllRowTs(args.TableName, args.Row, args.Timestamp, args.Attributes);
          }
          catch (IOError io)
          {
            result.Io = io;
          }
          oprot.WriteMessageBegin(new TMessage("deleteAllRowTs", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("deleteAllRowTs", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void scannerOpenWithScan_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        scannerOpenWithScan_args args = new scannerOpenWithScan_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        scannerOpenWithScan_result result = new scannerOpenWithScan_result();
        try
        {
          try
          {
            result.Success = iface_.scannerOpenWithScan(args.TableName, args.Scan, args.Attributes);
          }
          catch (IOError io)
          {
            result.Io = io;
          }
          oprot.WriteMessageBegin(new TMessage("scannerOpenWithScan", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("scannerOpenWithScan", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void scannerOpen_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        scannerOpen_args args = new scannerOpen_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        scannerOpen_result result = new scannerOpen_result();
        try
        {
          try
          {
            result.Success = iface_.scannerOpen(args.TableName, args.StartRow, args.Columns, args.Attributes);
          }
          catch (IOError io)
          {
            result.Io = io;
          }
          oprot.WriteMessageBegin(new TMessage("scannerOpen", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("scannerOpen", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void scannerOpenWithStop_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        scannerOpenWithStop_args args = new scannerOpenWithStop_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        scannerOpenWithStop_result result = new scannerOpenWithStop_result();
        try
        {
          try
          {
            result.Success = iface_.scannerOpenWithStop(args.TableName, args.StartRow, args.StopRow, args.Columns, args.Attributes);
          }
          catch (IOError io)
          {
            result.Io = io;
          }
          oprot.WriteMessageBegin(new TMessage("scannerOpenWithStop", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("scannerOpenWithStop", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void scannerOpenWithPrefix_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        scannerOpenWithPrefix_args args = new scannerOpenWithPrefix_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        scannerOpenWithPrefix_result result = new scannerOpenWithPrefix_result();
        try
        {
          try
          {
            result.Success = iface_.scannerOpenWithPrefix(args.TableName, args.StartAndPrefix, args.Columns, args.Attributes);
          }
          catch (IOError io)
          {
            result.Io = io;
          }
          oprot.WriteMessageBegin(new TMessage("scannerOpenWithPrefix", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("scannerOpenWithPrefix", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void scannerOpenTs_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        scannerOpenTs_args args = new scannerOpenTs_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        scannerOpenTs_result result = new scannerOpenTs_result();
        try
        {
          try
          {
            result.Success = iface_.scannerOpenTs(args.TableName, args.StartRow, args.Columns, args.Timestamp, args.Attributes);
          }
          catch (IOError io)
          {
            result.Io = io;
          }
          oprot.WriteMessageBegin(new TMessage("scannerOpenTs", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("scannerOpenTs", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void scannerOpenWithStopTs_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        scannerOpenWithStopTs_args args = new scannerOpenWithStopTs_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        scannerOpenWithStopTs_result result = new scannerOpenWithStopTs_result();
        try
        {
          try
          {
            result.Success = iface_.scannerOpenWithStopTs(args.TableName, args.StartRow, args.StopRow, args.Columns, args.Timestamp, args.Attributes);
          }
          catch (IOError io)
          {
            result.Io = io;
          }
          oprot.WriteMessageBegin(new TMessage("scannerOpenWithStopTs", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("scannerOpenWithStopTs", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void scannerGet_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        scannerGet_args args = new scannerGet_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        scannerGet_result result = new scannerGet_result();
        try
        {
          try
          {
            result.Success = iface_.scannerGet(args.Id);
          }
          catch (IOError io)
          {
            result.Io = io;
          }
          catch (IllegalArgument ia)
          {
            result.Ia = ia;
          }
          oprot.WriteMessageBegin(new TMessage("scannerGet", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("scannerGet", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void scannerGetList_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        scannerGetList_args args = new scannerGetList_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        scannerGetList_result result = new scannerGetList_result();
        try
        {
          try
          {
            result.Success = iface_.scannerGetList(args.Id, args.NbRows);
          }
          catch (IOError io)
          {
            result.Io = io;
          }
          catch (IllegalArgument ia)
          {
            result.Ia = ia;
          }
          oprot.WriteMessageBegin(new TMessage("scannerGetList", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("scannerGetList", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void scannerClose_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        scannerClose_args args = new scannerClose_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        scannerClose_result result = new scannerClose_result();
        try
        {
          try
          {
            iface_.scannerClose(args.Id);
          }
          catch (IOError io)
          {
            result.Io = io;
          }
          catch (IllegalArgument ia)
          {
            result.Ia = ia;
          }
          oprot.WriteMessageBegin(new TMessage("scannerClose", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("scannerClose", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void getRowOrBefore_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        getRowOrBefore_args args = new getRowOrBefore_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        getRowOrBefore_result result = new getRowOrBefore_result();
        try
        {
          try
          {
            result.Success = iface_.getRowOrBefore(args.TableName, args.Row, args.Family);
          }
          catch (IOError io)
          {
            result.Io = io;
          }
          oprot.WriteMessageBegin(new TMessage("getRowOrBefore", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("getRowOrBefore", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void getRegionInfo_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        getRegionInfo_args args = new getRegionInfo_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        getRegionInfo_result result = new getRegionInfo_result();
        try
        {
          try
          {
            result.Success = iface_.getRegionInfo(args.Row);
          }
          catch (IOError io)
          {
            result.Io = io;
          }
          oprot.WriteMessageBegin(new TMessage("getRegionInfo", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("getRegionInfo", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void append_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        append_args args = new append_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        append_result result = new append_result();
        try
        {
          try
          {
            result.Success = iface_.append(args.Append);
          }
          catch (IOError io)
          {
            result.Io = io;
          }
          oprot.WriteMessageBegin(new TMessage("append", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("append", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void checkAndPut_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        checkAndPut_args args = new checkAndPut_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        checkAndPut_result result = new checkAndPut_result();
        try
        {
          try
          {
            result.Success = iface_.checkAndPut(args.TableName, args.Row, args.Column, args.Value, args.Mput, args.Attributes);
          }
          catch (IOError io)
          {
            result.Io = io;
          }
          catch (IllegalArgument ia)
          {
            result.Ia = ia;
          }
          oprot.WriteMessageBegin(new TMessage("checkAndPut", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("checkAndPut", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class enableTable_args : TBase
    {
      private byte[] _tableName;

      /// <summary>
      /// name of the table
      /// </summary>
      public byte[] TableName
      {
        get
        {
          return _tableName;
        }
        set
        {
          __isset.tableName = true;
          this._tableName = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool tableName;
      }

      public enableTable_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  TableName = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("enableTable_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (TableName != null && __isset.tableName) {
            field.Name = "tableName";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(TableName);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("enableTable_args(");
        bool __first = true;
        if (TableName != null && __isset.tableName) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("TableName: ");
          __sb.Append(TableName);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class enableTable_result : TBase
    {
      private IOError _io;

      public IOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool io;
      }

      public enableTable_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new IOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("enableTable_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("enableTable_result(");
        bool __first = true;
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class disableTable_args : TBase
    {
      private byte[] _tableName;

      /// <summary>
      /// name of the table
      /// </summary>
      public byte[] TableName
      {
        get
        {
          return _tableName;
        }
        set
        {
          __isset.tableName = true;
          this._tableName = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool tableName;
      }

      public disableTable_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  TableName = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("disableTable_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (TableName != null && __isset.tableName) {
            field.Name = "tableName";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(TableName);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("disableTable_args(");
        bool __first = true;
        if (TableName != null && __isset.tableName) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("TableName: ");
          __sb.Append(TableName);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class disableTable_result : TBase
    {
      private IOError _io;

      public IOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool io;
      }

      public disableTable_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new IOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("disableTable_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("disableTable_result(");
        bool __first = true;
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class isTableEnabled_args : TBase
    {
      private byte[] _tableName;

      /// <summary>
      /// name of the table to check
      /// </summary>
      public byte[] TableName
      {
        get
        {
          return _tableName;
        }
        set
        {
          __isset.tableName = true;
          this._tableName = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool tableName;
      }

      public isTableEnabled_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  TableName = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("isTableEnabled_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (TableName != null && __isset.tableName) {
            field.Name = "tableName";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(TableName);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("isTableEnabled_args(");
        bool __first = true;
        if (TableName != null && __isset.tableName) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("TableName: ");
          __sb.Append(TableName);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class isTableEnabled_result : TBase
    {
      private bool _success;
      private IOError _io;

      public bool Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public IOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool io;
      }

      public isTableEnabled_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Bool) {
                  Success = iprot.ReadBool();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new IOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("isTableEnabled_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            field.Name = "Success";
            field.Type = TType.Bool;
            field.ID = 0;
            oprot.WriteFieldBegin(field);
            oprot.WriteBool(Success);
            oprot.WriteFieldEnd();
          } else if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("isTableEnabled_result(");
        bool __first = true;
        if (__isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class compact_args : TBase
    {
      private byte[] _tableNameOrRegionName;

      public byte[] TableNameOrRegionName
      {
        get
        {
          return _tableNameOrRegionName;
        }
        set
        {
          __isset.tableNameOrRegionName = true;
          this._tableNameOrRegionName = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool tableNameOrRegionName;
      }

      public compact_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  TableNameOrRegionName = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("compact_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (TableNameOrRegionName != null && __isset.tableNameOrRegionName) {
            field.Name = "tableNameOrRegionName";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(TableNameOrRegionName);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("compact_args(");
        bool __first = true;
        if (TableNameOrRegionName != null && __isset.tableNameOrRegionName) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("TableNameOrRegionName: ");
          __sb.Append(TableNameOrRegionName);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class compact_result : TBase
    {
      private IOError _io;

      public IOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool io;
      }

      public compact_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new IOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("compact_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("compact_result(");
        bool __first = true;
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class majorCompact_args : TBase
    {
      private byte[] _tableNameOrRegionName;

      public byte[] TableNameOrRegionName
      {
        get
        {
          return _tableNameOrRegionName;
        }
        set
        {
          __isset.tableNameOrRegionName = true;
          this._tableNameOrRegionName = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool tableNameOrRegionName;
      }

      public majorCompact_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  TableNameOrRegionName = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("majorCompact_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (TableNameOrRegionName != null && __isset.tableNameOrRegionName) {
            field.Name = "tableNameOrRegionName";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(TableNameOrRegionName);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("majorCompact_args(");
        bool __first = true;
        if (TableNameOrRegionName != null && __isset.tableNameOrRegionName) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("TableNameOrRegionName: ");
          __sb.Append(TableNameOrRegionName);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class majorCompact_result : TBase
    {
      private IOError _io;

      public IOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool io;
      }

      public majorCompact_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new IOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("majorCompact_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("majorCompact_result(");
        bool __first = true;
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getTableNames_args : TBase
    {

      public getTableNames_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getTableNames_args");
          oprot.WriteStructBegin(struc);
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getTableNames_args(");
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getTableNames_result : TBase
    {
      private List<byte[]> _success;
      private IOError _io;

      public List<byte[]> Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public IOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool io;
      }

      public getTableNames_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.List) {
                  {
                    Success = new List<byte[]>();
                    TList _list25 = iprot.ReadListBegin();
                    for( int _i26 = 0; _i26 < _list25.Count; ++_i26)
                    {
                      byte[] _elem27;
                      _elem27 = iprot.ReadBinary();
                      Success.Add(_elem27);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new IOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getTableNames_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.List;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              {
                oprot.WriteListBegin(new TList(TType.String, Success.Count));
                foreach (byte[] _iter28 in Success)
                {
                  oprot.WriteBinary(_iter28);
                }
                oprot.WriteListEnd();
              }
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getTableNames_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getColumnDescriptors_args : TBase
    {
      private byte[] _tableName;

      /// <summary>
      /// table name
      /// </summary>
      public byte[] TableName
      {
        get
        {
          return _tableName;
        }
        set
        {
          __isset.tableName = true;
          this._tableName = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool tableName;
      }

      public getColumnDescriptors_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  TableName = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getColumnDescriptors_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (TableName != null && __isset.tableName) {
            field.Name = "tableName";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(TableName);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getColumnDescriptors_args(");
        bool __first = true;
        if (TableName != null && __isset.tableName) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("TableName: ");
          __sb.Append(TableName);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getColumnDescriptors_result : TBase
    {
      private Dictionary<byte[], ColumnDescriptor> _success;
      private IOError _io;

      public Dictionary<byte[], ColumnDescriptor> Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public IOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool io;
      }

      public getColumnDescriptors_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Map) {
                  {
                    Success = new Dictionary<byte[], ColumnDescriptor>();
                    TMap _map29 = iprot.ReadMapBegin();
                    for( int _i30 = 0; _i30 < _map29.Count; ++_i30)
                    {
                      byte[] _key31;
                      ColumnDescriptor _val32;
                      _key31 = iprot.ReadBinary();
                      _val32 = new ColumnDescriptor();
                      _val32.Read(iprot);
                      Success[_key31] = _val32;
                    }
                    iprot.ReadMapEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new IOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getColumnDescriptors_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Map;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              {
                oprot.WriteMapBegin(new TMap(TType.String, TType.Struct, Success.Count));
                foreach (byte[] _iter33 in Success.Keys)
                {
                  oprot.WriteBinary(_iter33);
                  Success[_iter33].Write(oprot);
                }
                oprot.WriteMapEnd();
              }
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getColumnDescriptors_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getTableRegions_args : TBase
    {
      private byte[] _tableName;

      /// <summary>
      /// table name
      /// </summary>
      public byte[] TableName
      {
        get
        {
          return _tableName;
        }
        set
        {
          __isset.tableName = true;
          this._tableName = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool tableName;
      }

      public getTableRegions_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  TableName = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getTableRegions_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (TableName != null && __isset.tableName) {
            field.Name = "tableName";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(TableName);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getTableRegions_args(");
        bool __first = true;
        if (TableName != null && __isset.tableName) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("TableName: ");
          __sb.Append(TableName);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getTableRegions_result : TBase
    {
      private List<TRegionInfo> _success;
      private IOError _io;

      public List<TRegionInfo> Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public IOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool io;
      }

      public getTableRegions_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.List) {
                  {
                    Success = new List<TRegionInfo>();
                    TList _list34 = iprot.ReadListBegin();
                    for( int _i35 = 0; _i35 < _list34.Count; ++_i35)
                    {
                      TRegionInfo _elem36;
                      _elem36 = new TRegionInfo();
                      _elem36.Read(iprot);
                      Success.Add(_elem36);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new IOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getTableRegions_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.List;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              {
                oprot.WriteListBegin(new TList(TType.Struct, Success.Count));
                foreach (TRegionInfo _iter37 in Success)
                {
                  _iter37.Write(oprot);
                }
                oprot.WriteListEnd();
              }
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getTableRegions_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class createTable_args : TBase
    {
      private byte[] _tableName;
      private List<ColumnDescriptor> _columnFamilies;

      /// <summary>
      /// name of table to create
      /// </summary>
      public byte[] TableName
      {
        get
        {
          return _tableName;
        }
        set
        {
          __isset.tableName = true;
          this._tableName = value;
        }
      }

      /// <summary>
      /// list of column family descriptors
      /// </summary>
      public List<ColumnDescriptor> ColumnFamilies
      {
        get
        {
          return _columnFamilies;
        }
        set
        {
          __isset.columnFamilies = true;
          this._columnFamilies = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool tableName;
        public bool columnFamilies;
      }

      public createTable_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  TableName = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.List) {
                  {
                    ColumnFamilies = new List<ColumnDescriptor>();
                    TList _list38 = iprot.ReadListBegin();
                    for( int _i39 = 0; _i39 < _list38.Count; ++_i39)
                    {
                      ColumnDescriptor _elem40;
                      _elem40 = new ColumnDescriptor();
                      _elem40.Read(iprot);
                      ColumnFamilies.Add(_elem40);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("createTable_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (TableName != null && __isset.tableName) {
            field.Name = "tableName";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(TableName);
            oprot.WriteFieldEnd();
          }
          if (ColumnFamilies != null && __isset.columnFamilies) {
            field.Name = "columnFamilies";
            field.Type = TType.List;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            {
              oprot.WriteListBegin(new TList(TType.Struct, ColumnFamilies.Count));
              foreach (ColumnDescriptor _iter41 in ColumnFamilies)
              {
                _iter41.Write(oprot);
              }
              oprot.WriteListEnd();
            }
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("createTable_args(");
        bool __first = true;
        if (TableName != null && __isset.tableName) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("TableName: ");
          __sb.Append(TableName);
        }
        if (ColumnFamilies != null && __isset.columnFamilies) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("ColumnFamilies: ");
          __sb.Append(ColumnFamilies);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class createTable_result : TBase
    {
      private IOError _io;
      private IllegalArgument _ia;
      private AlreadyExists _exist;

      public IOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }

      public IllegalArgument Ia
      {
        get
        {
          return _ia;
        }
        set
        {
          __isset.ia = true;
          this._ia = value;
        }
      }

      public AlreadyExists Exist
      {
        get
        {
          return _exist;
        }
        set
        {
          __isset.exist = true;
          this._exist = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool io;
        public bool ia;
        public bool exist;
      }

      public createTable_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new IOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Ia = new IllegalArgument();
                  Ia.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  Exist = new AlreadyExists();
                  Exist.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("createTable_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.ia) {
            if (Ia != null) {
              field.Name = "Ia";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              Ia.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.exist) {
            if (Exist != null) {
              field.Name = "Exist";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              Exist.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("createTable_result(");
        bool __first = true;
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        if (Ia != null && __isset.ia) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ia: ");
          __sb.Append(Ia== null ? "<null>" : Ia.ToString());
        }
        if (Exist != null && __isset.exist) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Exist: ");
          __sb.Append(Exist== null ? "<null>" : Exist.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class deleteTable_args : TBase
    {
      private byte[] _tableName;

      /// <summary>
      /// name of table to delete
      /// </summary>
      public byte[] TableName
      {
        get
        {
          return _tableName;
        }
        set
        {
          __isset.tableName = true;
          this._tableName = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool tableName;
      }

      public deleteTable_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  TableName = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("deleteTable_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (TableName != null && __isset.tableName) {
            field.Name = "tableName";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(TableName);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("deleteTable_args(");
        bool __first = true;
        if (TableName != null && __isset.tableName) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("TableName: ");
          __sb.Append(TableName);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class deleteTable_result : TBase
    {
      private IOError _io;

      public IOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool io;
      }

      public deleteTable_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new IOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("deleteTable_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("deleteTable_result(");
        bool __first = true;
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class get_args : TBase
    {
      private byte[] _tableName;
      private byte[] _row;
      private byte[] _column;
      private Dictionary<byte[], byte[]> _attributes;

      /// <summary>
      /// name of table
      /// </summary>
      public byte[] TableName
      {
        get
        {
          return _tableName;
        }
        set
        {
          __isset.tableName = true;
          this._tableName = value;
        }
      }

      /// <summary>
      /// row key
      /// </summary>
      public byte[] Row
      {
        get
        {
          return _row;
        }
        set
        {
          __isset.row = true;
          this._row = value;
        }
      }

      /// <summary>
      /// column name
      /// </summary>
      public byte[] Column
      {
        get
        {
          return _column;
        }
        set
        {
          __isset.column = true;
          this._column = value;
        }
      }

      /// <summary>
      /// Get attributes
      /// </summary>
      public Dictionary<byte[], byte[]> Attributes
      {
        get
        {
          return _attributes;
        }
        set
        {
          __isset.attributes = true;
          this._attributes = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool tableName;
        public bool row;
        public bool column;
        public bool attributes;
      }

      public get_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  TableName = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Row = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.String) {
                  Column = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 4:
                if (field.Type == TType.Map) {
                  {
                    Attributes = new Dictionary<byte[], byte[]>();
                    TMap _map42 = iprot.ReadMapBegin();
                    for( int _i43 = 0; _i43 < _map42.Count; ++_i43)
                    {
                      byte[] _key44;
                      byte[] _val45;
                      _key44 = iprot.ReadBinary();
                      _val45 = iprot.ReadBinary();
                      Attributes[_key44] = _val45;
                    }
                    iprot.ReadMapEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("get_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (TableName != null && __isset.tableName) {
            field.Name = "tableName";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(TableName);
            oprot.WriteFieldEnd();
          }
          if (Row != null && __isset.row) {
            field.Name = "row";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(Row);
            oprot.WriteFieldEnd();
          }
          if (Column != null && __isset.column) {
            field.Name = "column";
            field.Type = TType.String;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(Column);
            oprot.WriteFieldEnd();
          }
          if (Attributes != null && __isset.attributes) {
            field.Name = "attributes";
            field.Type = TType.Map;
            field.ID = 4;
            oprot.WriteFieldBegin(field);
            {
              oprot.WriteMapBegin(new TMap(TType.String, TType.String, Attributes.Count));
              foreach (byte[] _iter46 in Attributes.Keys)
              {
                oprot.WriteBinary(_iter46);
                oprot.WriteBinary(Attributes[_iter46]);
              }
              oprot.WriteMapEnd();
            }
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("get_args(");
        bool __first = true;
        if (TableName != null && __isset.tableName) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("TableName: ");
          __sb.Append(TableName);
        }
        if (Row != null && __isset.row) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Row: ");
          __sb.Append(Row);
        }
        if (Column != null && __isset.column) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Column: ");
          __sb.Append(Column);
        }
        if (Attributes != null && __isset.attributes) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Attributes: ");
          __sb.Append(Attributes);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class get_result : TBase
    {
      private List<TCell> _success;
      private IOError _io;

      public List<TCell> Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public IOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool io;
      }

      public get_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.List) {
                  {
                    Success = new List<TCell>();
                    TList _list47 = iprot.ReadListBegin();
                    for( int _i48 = 0; _i48 < _list47.Count; ++_i48)
                    {
                      TCell _elem49;
                      _elem49 = new TCell();
                      _elem49.Read(iprot);
                      Success.Add(_elem49);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new IOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("get_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.List;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              {
                oprot.WriteListBegin(new TList(TType.Struct, Success.Count));
                foreach (TCell _iter50 in Success)
                {
                  _iter50.Write(oprot);
                }
                oprot.WriteListEnd();
              }
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("get_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getVer_args : TBase
    {
      private byte[] _tableName;
      private byte[] _row;
      private byte[] _column;
      private int _numVersions;
      private Dictionary<byte[], byte[]> _attributes;

      /// <summary>
      /// name of table
      /// </summary>
      public byte[] TableName
      {
        get
        {
          return _tableName;
        }
        set
        {
          __isset.tableName = true;
          this._tableName = value;
        }
      }

      /// <summary>
      /// row key
      /// </summary>
      public byte[] Row
      {
        get
        {
          return _row;
        }
        set
        {
          __isset.row = true;
          this._row = value;
        }
      }

      /// <summary>
      /// column name
      /// </summary>
      public byte[] Column
      {
        get
        {
          return _column;
        }
        set
        {
          __isset.column = true;
          this._column = value;
        }
      }

      /// <summary>
      /// number of versions to retrieve
      /// </summary>
      public int NumVersions
      {
        get
        {
          return _numVersions;
        }
        set
        {
          __isset.numVersions = true;
          this._numVersions = value;
        }
      }

      /// <summary>
      /// Get attributes
      /// </summary>
      public Dictionary<byte[], byte[]> Attributes
      {
        get
        {
          return _attributes;
        }
        set
        {
          __isset.attributes = true;
          this._attributes = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool tableName;
        public bool row;
        public bool column;
        public bool numVersions;
        public bool attributes;
      }

      public getVer_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  TableName = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Row = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.String) {
                  Column = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 4:
                if (field.Type == TType.I32) {
                  NumVersions = iprot.ReadI32();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 5:
                if (field.Type == TType.Map) {
                  {
                    Attributes = new Dictionary<byte[], byte[]>();
                    TMap _map51 = iprot.ReadMapBegin();
                    for( int _i52 = 0; _i52 < _map51.Count; ++_i52)
                    {
                      byte[] _key53;
                      byte[] _val54;
                      _key53 = iprot.ReadBinary();
                      _val54 = iprot.ReadBinary();
                      Attributes[_key53] = _val54;
                    }
                    iprot.ReadMapEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getVer_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (TableName != null && __isset.tableName) {
            field.Name = "tableName";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(TableName);
            oprot.WriteFieldEnd();
          }
          if (Row != null && __isset.row) {
            field.Name = "row";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(Row);
            oprot.WriteFieldEnd();
          }
          if (Column != null && __isset.column) {
            field.Name = "column";
            field.Type = TType.String;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(Column);
            oprot.WriteFieldEnd();
          }
          if (__isset.numVersions) {
            field.Name = "numVersions";
            field.Type = TType.I32;
            field.ID = 4;
            oprot.WriteFieldBegin(field);
            oprot.WriteI32(NumVersions);
            oprot.WriteFieldEnd();
          }
          if (Attributes != null && __isset.attributes) {
            field.Name = "attributes";
            field.Type = TType.Map;
            field.ID = 5;
            oprot.WriteFieldBegin(field);
            {
              oprot.WriteMapBegin(new TMap(TType.String, TType.String, Attributes.Count));
              foreach (byte[] _iter55 in Attributes.Keys)
              {
                oprot.WriteBinary(_iter55);
                oprot.WriteBinary(Attributes[_iter55]);
              }
              oprot.WriteMapEnd();
            }
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getVer_args(");
        bool __first = true;
        if (TableName != null && __isset.tableName) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("TableName: ");
          __sb.Append(TableName);
        }
        if (Row != null && __isset.row) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Row: ");
          __sb.Append(Row);
        }
        if (Column != null && __isset.column) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Column: ");
          __sb.Append(Column);
        }
        if (__isset.numVersions) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NumVersions: ");
          __sb.Append(NumVersions);
        }
        if (Attributes != null && __isset.attributes) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Attributes: ");
          __sb.Append(Attributes);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getVer_result : TBase
    {
      private List<TCell> _success;
      private IOError _io;

      public List<TCell> Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public IOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool io;
      }

      public getVer_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.List) {
                  {
                    Success = new List<TCell>();
                    TList _list56 = iprot.ReadListBegin();
                    for( int _i57 = 0; _i57 < _list56.Count; ++_i57)
                    {
                      TCell _elem58;
                      _elem58 = new TCell();
                      _elem58.Read(iprot);
                      Success.Add(_elem58);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new IOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getVer_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.List;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              {
                oprot.WriteListBegin(new TList(TType.Struct, Success.Count));
                foreach (TCell _iter59 in Success)
                {
                  _iter59.Write(oprot);
                }
                oprot.WriteListEnd();
              }
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getVer_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getVerTs_args : TBase
    {
      private byte[] _tableName;
      private byte[] _row;
      private byte[] _column;
      private long _timestamp;
      private int _numVersions;
      private Dictionary<byte[], byte[]> _attributes;

      /// <summary>
      /// name of table
      /// </summary>
      public byte[] TableName
      {
        get
        {
          return _tableName;
        }
        set
        {
          __isset.tableName = true;
          this._tableName = value;
        }
      }

      /// <summary>
      /// row key
      /// </summary>
      public byte[] Row
      {
        get
        {
          return _row;
        }
        set
        {
          __isset.row = true;
          this._row = value;
        }
      }

      /// <summary>
      /// column name
      /// </summary>
      public byte[] Column
      {
        get
        {
          return _column;
        }
        set
        {
          __isset.column = true;
          this._column = value;
        }
      }

      /// <summary>
      /// timestamp
      /// </summary>
      public long Timestamp
      {
        get
        {
          return _timestamp;
        }
        set
        {
          __isset.timestamp = true;
          this._timestamp = value;
        }
      }

      /// <summary>
      /// number of versions to retrieve
      /// </summary>
      public int NumVersions
      {
        get
        {
          return _numVersions;
        }
        set
        {
          __isset.numVersions = true;
          this._numVersions = value;
        }
      }

      /// <summary>
      /// Get attributes
      /// </summary>
      public Dictionary<byte[], byte[]> Attributes
      {
        get
        {
          return _attributes;
        }
        set
        {
          __isset.attributes = true;
          this._attributes = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool tableName;
        public bool row;
        public bool column;
        public bool timestamp;
        public bool numVersions;
        public bool attributes;
      }

      public getVerTs_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  TableName = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Row = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.String) {
                  Column = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 4:
                if (field.Type == TType.I64) {
                  Timestamp = iprot.ReadI64();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 5:
                if (field.Type == TType.I32) {
                  NumVersions = iprot.ReadI32();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 6:
                if (field.Type == TType.Map) {
                  {
                    Attributes = new Dictionary<byte[], byte[]>();
                    TMap _map60 = iprot.ReadMapBegin();
                    for( int _i61 = 0; _i61 < _map60.Count; ++_i61)
                    {
                      byte[] _key62;
                      byte[] _val63;
                      _key62 = iprot.ReadBinary();
                      _val63 = iprot.ReadBinary();
                      Attributes[_key62] = _val63;
                    }
                    iprot.ReadMapEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getVerTs_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (TableName != null && __isset.tableName) {
            field.Name = "tableName";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(TableName);
            oprot.WriteFieldEnd();
          }
          if (Row != null && __isset.row) {
            field.Name = "row";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(Row);
            oprot.WriteFieldEnd();
          }
          if (Column != null && __isset.column) {
            field.Name = "column";
            field.Type = TType.String;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(Column);
            oprot.WriteFieldEnd();
          }
          if (__isset.timestamp) {
            field.Name = "timestamp";
            field.Type = TType.I64;
            field.ID = 4;
            oprot.WriteFieldBegin(field);
            oprot.WriteI64(Timestamp);
            oprot.WriteFieldEnd();
          }
          if (__isset.numVersions) {
            field.Name = "numVersions";
            field.Type = TType.I32;
            field.ID = 5;
            oprot.WriteFieldBegin(field);
            oprot.WriteI32(NumVersions);
            oprot.WriteFieldEnd();
          }
          if (Attributes != null && __isset.attributes) {
            field.Name = "attributes";
            field.Type = TType.Map;
            field.ID = 6;
            oprot.WriteFieldBegin(field);
            {
              oprot.WriteMapBegin(new TMap(TType.String, TType.String, Attributes.Count));
              foreach (byte[] _iter64 in Attributes.Keys)
              {
                oprot.WriteBinary(_iter64);
                oprot.WriteBinary(Attributes[_iter64]);
              }
              oprot.WriteMapEnd();
            }
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getVerTs_args(");
        bool __first = true;
        if (TableName != null && __isset.tableName) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("TableName: ");
          __sb.Append(TableName);
        }
        if (Row != null && __isset.row) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Row: ");
          __sb.Append(Row);
        }
        if (Column != null && __isset.column) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Column: ");
          __sb.Append(Column);
        }
        if (__isset.timestamp) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Timestamp: ");
          __sb.Append(Timestamp);
        }
        if (__isset.numVersions) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NumVersions: ");
          __sb.Append(NumVersions);
        }
        if (Attributes != null && __isset.attributes) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Attributes: ");
          __sb.Append(Attributes);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getVerTs_result : TBase
    {
      private List<TCell> _success;
      private IOError _io;

      public List<TCell> Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public IOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool io;
      }

      public getVerTs_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.List) {
                  {
                    Success = new List<TCell>();
                    TList _list65 = iprot.ReadListBegin();
                    for( int _i66 = 0; _i66 < _list65.Count; ++_i66)
                    {
                      TCell _elem67;
                      _elem67 = new TCell();
                      _elem67.Read(iprot);
                      Success.Add(_elem67);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new IOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getVerTs_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.List;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              {
                oprot.WriteListBegin(new TList(TType.Struct, Success.Count));
                foreach (TCell _iter68 in Success)
                {
                  _iter68.Write(oprot);
                }
                oprot.WriteListEnd();
              }
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getVerTs_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getRow_args : TBase
    {
      private byte[] _tableName;
      private byte[] _row;
      private Dictionary<byte[], byte[]> _attributes;

      /// <summary>
      /// name of table
      /// </summary>
      public byte[] TableName
      {
        get
        {
          return _tableName;
        }
        set
        {
          __isset.tableName = true;
          this._tableName = value;
        }
      }

      /// <summary>
      /// row key
      /// </summary>
      public byte[] Row
      {
        get
        {
          return _row;
        }
        set
        {
          __isset.row = true;
          this._row = value;
        }
      }

      /// <summary>
      /// Get attributes
      /// </summary>
      public Dictionary<byte[], byte[]> Attributes
      {
        get
        {
          return _attributes;
        }
        set
        {
          __isset.attributes = true;
          this._attributes = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool tableName;
        public bool row;
        public bool attributes;
      }

      public getRow_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  TableName = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Row = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Map) {
                  {
                    Attributes = new Dictionary<byte[], byte[]>();
                    TMap _map69 = iprot.ReadMapBegin();
                    for( int _i70 = 0; _i70 < _map69.Count; ++_i70)
                    {
                      byte[] _key71;
                      byte[] _val72;
                      _key71 = iprot.ReadBinary();
                      _val72 = iprot.ReadBinary();
                      Attributes[_key71] = _val72;
                    }
                    iprot.ReadMapEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getRow_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (TableName != null && __isset.tableName) {
            field.Name = "tableName";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(TableName);
            oprot.WriteFieldEnd();
          }
          if (Row != null && __isset.row) {
            field.Name = "row";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(Row);
            oprot.WriteFieldEnd();
          }
          if (Attributes != null && __isset.attributes) {
            field.Name = "attributes";
            field.Type = TType.Map;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            {
              oprot.WriteMapBegin(new TMap(TType.String, TType.String, Attributes.Count));
              foreach (byte[] _iter73 in Attributes.Keys)
              {
                oprot.WriteBinary(_iter73);
                oprot.WriteBinary(Attributes[_iter73]);
              }
              oprot.WriteMapEnd();
            }
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getRow_args(");
        bool __first = true;
        if (TableName != null && __isset.tableName) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("TableName: ");
          __sb.Append(TableName);
        }
        if (Row != null && __isset.row) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Row: ");
          __sb.Append(Row);
        }
        if (Attributes != null && __isset.attributes) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Attributes: ");
          __sb.Append(Attributes);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getRow_result : TBase
    {
      private List<TRowResult> _success;
      private IOError _io;

      public List<TRowResult> Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public IOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool io;
      }

      public getRow_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.List) {
                  {
                    Success = new List<TRowResult>();
                    TList _list74 = iprot.ReadListBegin();
                    for( int _i75 = 0; _i75 < _list74.Count; ++_i75)
                    {
                      TRowResult _elem76;
                      _elem76 = new TRowResult();
                      _elem76.Read(iprot);
                      Success.Add(_elem76);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new IOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getRow_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.List;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              {
                oprot.WriteListBegin(new TList(TType.Struct, Success.Count));
                foreach (TRowResult _iter77 in Success)
                {
                  _iter77.Write(oprot);
                }
                oprot.WriteListEnd();
              }
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getRow_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getRowWithColumns_args : TBase
    {
      private byte[] _tableName;
      private byte[] _row;
      private List<byte[]> _columns;
      private Dictionary<byte[], byte[]> _attributes;

      /// <summary>
      /// name of table
      /// </summary>
      public byte[] TableName
      {
        get
        {
          return _tableName;
        }
        set
        {
          __isset.tableName = true;
          this._tableName = value;
        }
      }

      /// <summary>
      /// row key
      /// </summary>
      public byte[] Row
      {
        get
        {
          return _row;
        }
        set
        {
          __isset.row = true;
          this._row = value;
        }
      }

      /// <summary>
      /// List of columns to return, null for all columns
      /// </summary>
      public List<byte[]> Columns
      {
        get
        {
          return _columns;
        }
        set
        {
          __isset.columns = true;
          this._columns = value;
        }
      }

      /// <summary>
      /// Get attributes
      /// </summary>
      public Dictionary<byte[], byte[]> Attributes
      {
        get
        {
          return _attributes;
        }
        set
        {
          __isset.attributes = true;
          this._attributes = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool tableName;
        public bool row;
        public bool columns;
        public bool attributes;
      }

      public getRowWithColumns_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  TableName = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Row = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.List) {
                  {
                    Columns = new List<byte[]>();
                    TList _list78 = iprot.ReadListBegin();
                    for( int _i79 = 0; _i79 < _list78.Count; ++_i79)
                    {
                      byte[] _elem80;
                      _elem80 = iprot.ReadBinary();
                      Columns.Add(_elem80);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 4:
                if (field.Type == TType.Map) {
                  {
                    Attributes = new Dictionary<byte[], byte[]>();
                    TMap _map81 = iprot.ReadMapBegin();
                    for( int _i82 = 0; _i82 < _map81.Count; ++_i82)
                    {
                      byte[] _key83;
                      byte[] _val84;
                      _key83 = iprot.ReadBinary();
                      _val84 = iprot.ReadBinary();
                      Attributes[_key83] = _val84;
                    }
                    iprot.ReadMapEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getRowWithColumns_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (TableName != null && __isset.tableName) {
            field.Name = "tableName";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(TableName);
            oprot.WriteFieldEnd();
          }
          if (Row != null && __isset.row) {
            field.Name = "row";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(Row);
            oprot.WriteFieldEnd();
          }
          if (Columns != null && __isset.columns) {
            field.Name = "columns";
            field.Type = TType.List;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            {
              oprot.WriteListBegin(new TList(TType.String, Columns.Count));
              foreach (byte[] _iter85 in Columns)
              {
                oprot.WriteBinary(_iter85);
              }
              oprot.WriteListEnd();
            }
            oprot.WriteFieldEnd();
          }
          if (Attributes != null && __isset.attributes) {
            field.Name = "attributes";
            field.Type = TType.Map;
            field.ID = 4;
            oprot.WriteFieldBegin(field);
            {
              oprot.WriteMapBegin(new TMap(TType.String, TType.String, Attributes.Count));
              foreach (byte[] _iter86 in Attributes.Keys)
              {
                oprot.WriteBinary(_iter86);
                oprot.WriteBinary(Attributes[_iter86]);
              }
              oprot.WriteMapEnd();
            }
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getRowWithColumns_args(");
        bool __first = true;
        if (TableName != null && __isset.tableName) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("TableName: ");
          __sb.Append(TableName);
        }
        if (Row != null && __isset.row) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Row: ");
          __sb.Append(Row);
        }
        if (Columns != null && __isset.columns) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Columns: ");
          __sb.Append(Columns);
        }
        if (Attributes != null && __isset.attributes) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Attributes: ");
          __sb.Append(Attributes);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getRowWithColumns_result : TBase
    {
      private List<TRowResult> _success;
      private IOError _io;

      public List<TRowResult> Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public IOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool io;
      }

      public getRowWithColumns_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.List) {
                  {
                    Success = new List<TRowResult>();
                    TList _list87 = iprot.ReadListBegin();
                    for( int _i88 = 0; _i88 < _list87.Count; ++_i88)
                    {
                      TRowResult _elem89;
                      _elem89 = new TRowResult();
                      _elem89.Read(iprot);
                      Success.Add(_elem89);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new IOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getRowWithColumns_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.List;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              {
                oprot.WriteListBegin(new TList(TType.Struct, Success.Count));
                foreach (TRowResult _iter90 in Success)
                {
                  _iter90.Write(oprot);
                }
                oprot.WriteListEnd();
              }
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getRowWithColumns_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getRowTs_args : TBase
    {
      private byte[] _tableName;
      private byte[] _row;
      private long _timestamp;
      private Dictionary<byte[], byte[]> _attributes;

      /// <summary>
      /// name of the table
      /// </summary>
      public byte[] TableName
      {
        get
        {
          return _tableName;
        }
        set
        {
          __isset.tableName = true;
          this._tableName = value;
        }
      }

      /// <summary>
      /// row key
      /// </summary>
      public byte[] Row
      {
        get
        {
          return _row;
        }
        set
        {
          __isset.row = true;
          this._row = value;
        }
      }

      /// <summary>
      /// timestamp
      /// </summary>
      public long Timestamp
      {
        get
        {
          return _timestamp;
        }
        set
        {
          __isset.timestamp = true;
          this._timestamp = value;
        }
      }

      /// <summary>
      /// Get attributes
      /// </summary>
      public Dictionary<byte[], byte[]> Attributes
      {
        get
        {
          return _attributes;
        }
        set
        {
          __isset.attributes = true;
          this._attributes = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool tableName;
        public bool row;
        public bool timestamp;
        public bool attributes;
      }

      public getRowTs_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  TableName = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Row = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.I64) {
                  Timestamp = iprot.ReadI64();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 4:
                if (field.Type == TType.Map) {
                  {
                    Attributes = new Dictionary<byte[], byte[]>();
                    TMap _map91 = iprot.ReadMapBegin();
                    for( int _i92 = 0; _i92 < _map91.Count; ++_i92)
                    {
                      byte[] _key93;
                      byte[] _val94;
                      _key93 = iprot.ReadBinary();
                      _val94 = iprot.ReadBinary();
                      Attributes[_key93] = _val94;
                    }
                    iprot.ReadMapEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getRowTs_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (TableName != null && __isset.tableName) {
            field.Name = "tableName";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(TableName);
            oprot.WriteFieldEnd();
          }
          if (Row != null && __isset.row) {
            field.Name = "row";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(Row);
            oprot.WriteFieldEnd();
          }
          if (__isset.timestamp) {
            field.Name = "timestamp";
            field.Type = TType.I64;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            oprot.WriteI64(Timestamp);
            oprot.WriteFieldEnd();
          }
          if (Attributes != null && __isset.attributes) {
            field.Name = "attributes";
            field.Type = TType.Map;
            field.ID = 4;
            oprot.WriteFieldBegin(field);
            {
              oprot.WriteMapBegin(new TMap(TType.String, TType.String, Attributes.Count));
              foreach (byte[] _iter95 in Attributes.Keys)
              {
                oprot.WriteBinary(_iter95);
                oprot.WriteBinary(Attributes[_iter95]);
              }
              oprot.WriteMapEnd();
            }
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getRowTs_args(");
        bool __first = true;
        if (TableName != null && __isset.tableName) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("TableName: ");
          __sb.Append(TableName);
        }
        if (Row != null && __isset.row) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Row: ");
          __sb.Append(Row);
        }
        if (__isset.timestamp) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Timestamp: ");
          __sb.Append(Timestamp);
        }
        if (Attributes != null && __isset.attributes) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Attributes: ");
          __sb.Append(Attributes);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getRowTs_result : TBase
    {
      private List<TRowResult> _success;
      private IOError _io;

      public List<TRowResult> Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public IOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool io;
      }

      public getRowTs_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.List) {
                  {
                    Success = new List<TRowResult>();
                    TList _list96 = iprot.ReadListBegin();
                    for( int _i97 = 0; _i97 < _list96.Count; ++_i97)
                    {
                      TRowResult _elem98;
                      _elem98 = new TRowResult();
                      _elem98.Read(iprot);
                      Success.Add(_elem98);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new IOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getRowTs_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.List;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              {
                oprot.WriteListBegin(new TList(TType.Struct, Success.Count));
                foreach (TRowResult _iter99 in Success)
                {
                  _iter99.Write(oprot);
                }
                oprot.WriteListEnd();
              }
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getRowTs_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getRowWithColumnsTs_args : TBase
    {
      private byte[] _tableName;
      private byte[] _row;
      private List<byte[]> _columns;
      private long _timestamp;
      private Dictionary<byte[], byte[]> _attributes;

      /// <summary>
      /// name of table
      /// </summary>
      public byte[] TableName
      {
        get
        {
          return _tableName;
        }
        set
        {
          __isset.tableName = true;
          this._tableName = value;
        }
      }

      /// <summary>
      /// row key
      /// </summary>
      public byte[] Row
      {
        get
        {
          return _row;
        }
        set
        {
          __isset.row = true;
          this._row = value;
        }
      }

      /// <summary>
      /// List of columns to return, null for all columns
      /// </summary>
      public List<byte[]> Columns
      {
        get
        {
          return _columns;
        }
        set
        {
          __isset.columns = true;
          this._columns = value;
        }
      }

      public long Timestamp
      {
        get
        {
          return _timestamp;
        }
        set
        {
          __isset.timestamp = true;
          this._timestamp = value;
        }
      }

      /// <summary>
      /// Get attributes
      /// </summary>
      public Dictionary<byte[], byte[]> Attributes
      {
        get
        {
          return _attributes;
        }
        set
        {
          __isset.attributes = true;
          this._attributes = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool tableName;
        public bool row;
        public bool columns;
        public bool timestamp;
        public bool attributes;
      }

      public getRowWithColumnsTs_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  TableName = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Row = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.List) {
                  {
                    Columns = new List<byte[]>();
                    TList _list100 = iprot.ReadListBegin();
                    for( int _i101 = 0; _i101 < _list100.Count; ++_i101)
                    {
                      byte[] _elem102;
                      _elem102 = iprot.ReadBinary();
                      Columns.Add(_elem102);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 4:
                if (field.Type == TType.I64) {
                  Timestamp = iprot.ReadI64();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 5:
                if (field.Type == TType.Map) {
                  {
                    Attributes = new Dictionary<byte[], byte[]>();
                    TMap _map103 = iprot.ReadMapBegin();
                    for( int _i104 = 0; _i104 < _map103.Count; ++_i104)
                    {
                      byte[] _key105;
                      byte[] _val106;
                      _key105 = iprot.ReadBinary();
                      _val106 = iprot.ReadBinary();
                      Attributes[_key105] = _val106;
                    }
                    iprot.ReadMapEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getRowWithColumnsTs_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (TableName != null && __isset.tableName) {
            field.Name = "tableName";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(TableName);
            oprot.WriteFieldEnd();
          }
          if (Row != null && __isset.row) {
            field.Name = "row";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(Row);
            oprot.WriteFieldEnd();
          }
          if (Columns != null && __isset.columns) {
            field.Name = "columns";
            field.Type = TType.List;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            {
              oprot.WriteListBegin(new TList(TType.String, Columns.Count));
              foreach (byte[] _iter107 in Columns)
              {
                oprot.WriteBinary(_iter107);
              }
              oprot.WriteListEnd();
            }
            oprot.WriteFieldEnd();
          }
          if (__isset.timestamp) {
            field.Name = "timestamp";
            field.Type = TType.I64;
            field.ID = 4;
            oprot.WriteFieldBegin(field);
            oprot.WriteI64(Timestamp);
            oprot.WriteFieldEnd();
          }
          if (Attributes != null && __isset.attributes) {
            field.Name = "attributes";
            field.Type = TType.Map;
            field.ID = 5;
            oprot.WriteFieldBegin(field);
            {
              oprot.WriteMapBegin(new TMap(TType.String, TType.String, Attributes.Count));
              foreach (byte[] _iter108 in Attributes.Keys)
              {
                oprot.WriteBinary(_iter108);
                oprot.WriteBinary(Attributes[_iter108]);
              }
              oprot.WriteMapEnd();
            }
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getRowWithColumnsTs_args(");
        bool __first = true;
        if (TableName != null && __isset.tableName) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("TableName: ");
          __sb.Append(TableName);
        }
        if (Row != null && __isset.row) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Row: ");
          __sb.Append(Row);
        }
        if (Columns != null && __isset.columns) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Columns: ");
          __sb.Append(Columns);
        }
        if (__isset.timestamp) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Timestamp: ");
          __sb.Append(Timestamp);
        }
        if (Attributes != null && __isset.attributes) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Attributes: ");
          __sb.Append(Attributes);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getRowWithColumnsTs_result : TBase
    {
      private List<TRowResult> _success;
      private IOError _io;

      public List<TRowResult> Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public IOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool io;
      }

      public getRowWithColumnsTs_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.List) {
                  {
                    Success = new List<TRowResult>();
                    TList _list109 = iprot.ReadListBegin();
                    for( int _i110 = 0; _i110 < _list109.Count; ++_i110)
                    {
                      TRowResult _elem111;
                      _elem111 = new TRowResult();
                      _elem111.Read(iprot);
                      Success.Add(_elem111);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new IOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getRowWithColumnsTs_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.List;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              {
                oprot.WriteListBegin(new TList(TType.Struct, Success.Count));
                foreach (TRowResult _iter112 in Success)
                {
                  _iter112.Write(oprot);
                }
                oprot.WriteListEnd();
              }
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getRowWithColumnsTs_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getRows_args : TBase
    {
      private byte[] _tableName;
      private List<byte[]> _rows;
      private Dictionary<byte[], byte[]> _attributes;

      /// <summary>
      /// name of table
      /// </summary>
      public byte[] TableName
      {
        get
        {
          return _tableName;
        }
        set
        {
          __isset.tableName = true;
          this._tableName = value;
        }
      }

      /// <summary>
      /// row keys
      /// </summary>
      public List<byte[]> Rows
      {
        get
        {
          return _rows;
        }
        set
        {
          __isset.rows = true;
          this._rows = value;
        }
      }

      /// <summary>
      /// Get attributes
      /// </summary>
      public Dictionary<byte[], byte[]> Attributes
      {
        get
        {
          return _attributes;
        }
        set
        {
          __isset.attributes = true;
          this._attributes = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool tableName;
        public bool rows;
        public bool attributes;
      }

      public getRows_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  TableName = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.List) {
                  {
                    Rows = new List<byte[]>();
                    TList _list113 = iprot.ReadListBegin();
                    for( int _i114 = 0; _i114 < _list113.Count; ++_i114)
                    {
                      byte[] _elem115;
                      _elem115 = iprot.ReadBinary();
                      Rows.Add(_elem115);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Map) {
                  {
                    Attributes = new Dictionary<byte[], byte[]>();
                    TMap _map116 = iprot.ReadMapBegin();
                    for( int _i117 = 0; _i117 < _map116.Count; ++_i117)
                    {
                      byte[] _key118;
                      byte[] _val119;
                      _key118 = iprot.ReadBinary();
                      _val119 = iprot.ReadBinary();
                      Attributes[_key118] = _val119;
                    }
                    iprot.ReadMapEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getRows_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (TableName != null && __isset.tableName) {
            field.Name = "tableName";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(TableName);
            oprot.WriteFieldEnd();
          }
          if (Rows != null && __isset.rows) {
            field.Name = "rows";
            field.Type = TType.List;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            {
              oprot.WriteListBegin(new TList(TType.String, Rows.Count));
              foreach (byte[] _iter120 in Rows)
              {
                oprot.WriteBinary(_iter120);
              }
              oprot.WriteListEnd();
            }
            oprot.WriteFieldEnd();
          }
          if (Attributes != null && __isset.attributes) {
            field.Name = "attributes";
            field.Type = TType.Map;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            {
              oprot.WriteMapBegin(new TMap(TType.String, TType.String, Attributes.Count));
              foreach (byte[] _iter121 in Attributes.Keys)
              {
                oprot.WriteBinary(_iter121);
                oprot.WriteBinary(Attributes[_iter121]);
              }
              oprot.WriteMapEnd();
            }
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getRows_args(");
        bool __first = true;
        if (TableName != null && __isset.tableName) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("TableName: ");
          __sb.Append(TableName);
        }
        if (Rows != null && __isset.rows) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Rows: ");
          __sb.Append(Rows);
        }
        if (Attributes != null && __isset.attributes) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Attributes: ");
          __sb.Append(Attributes);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getRows_result : TBase
    {
      private List<TRowResult> _success;
      private IOError _io;

      public List<TRowResult> Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public IOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool io;
      }

      public getRows_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.List) {
                  {
                    Success = new List<TRowResult>();
                    TList _list122 = iprot.ReadListBegin();
                    for( int _i123 = 0; _i123 < _list122.Count; ++_i123)
                    {
                      TRowResult _elem124;
                      _elem124 = new TRowResult();
                      _elem124.Read(iprot);
                      Success.Add(_elem124);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new IOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getRows_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.List;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              {
                oprot.WriteListBegin(new TList(TType.Struct, Success.Count));
                foreach (TRowResult _iter125 in Success)
                {
                  _iter125.Write(oprot);
                }
                oprot.WriteListEnd();
              }
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getRows_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getRowsWithColumns_args : TBase
    {
      private byte[] _tableName;
      private List<byte[]> _rows;
      private List<byte[]> _columns;
      private Dictionary<byte[], byte[]> _attributes;

      /// <summary>
      /// name of table
      /// </summary>
      public byte[] TableName
      {
        get
        {
          return _tableName;
        }
        set
        {
          __isset.tableName = true;
          this._tableName = value;
        }
      }

      /// <summary>
      /// row keys
      /// </summary>
      public List<byte[]> Rows
      {
        get
        {
          return _rows;
        }
        set
        {
          __isset.rows = true;
          this._rows = value;
        }
      }

      /// <summary>
      /// List of columns to return, null for all columns
      /// </summary>
      public List<byte[]> Columns
      {
        get
        {
          return _columns;
        }
        set
        {
          __isset.columns = true;
          this._columns = value;
        }
      }

      /// <summary>
      /// Get attributes
      /// </summary>
      public Dictionary<byte[], byte[]> Attributes
      {
        get
        {
          return _attributes;
        }
        set
        {
          __isset.attributes = true;
          this._attributes = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool tableName;
        public bool rows;
        public bool columns;
        public bool attributes;
      }

      public getRowsWithColumns_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  TableName = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.List) {
                  {
                    Rows = new List<byte[]>();
                    TList _list126 = iprot.ReadListBegin();
                    for( int _i127 = 0; _i127 < _list126.Count; ++_i127)
                    {
                      byte[] _elem128;
                      _elem128 = iprot.ReadBinary();
                      Rows.Add(_elem128);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.List) {
                  {
                    Columns = new List<byte[]>();
                    TList _list129 = iprot.ReadListBegin();
                    for( int _i130 = 0; _i130 < _list129.Count; ++_i130)
                    {
                      byte[] _elem131;
                      _elem131 = iprot.ReadBinary();
                      Columns.Add(_elem131);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 4:
                if (field.Type == TType.Map) {
                  {
                    Attributes = new Dictionary<byte[], byte[]>();
                    TMap _map132 = iprot.ReadMapBegin();
                    for( int _i133 = 0; _i133 < _map132.Count; ++_i133)
                    {
                      byte[] _key134;
                      byte[] _val135;
                      _key134 = iprot.ReadBinary();
                      _val135 = iprot.ReadBinary();
                      Attributes[_key134] = _val135;
                    }
                    iprot.ReadMapEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getRowsWithColumns_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (TableName != null && __isset.tableName) {
            field.Name = "tableName";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(TableName);
            oprot.WriteFieldEnd();
          }
          if (Rows != null && __isset.rows) {
            field.Name = "rows";
            field.Type = TType.List;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            {
              oprot.WriteListBegin(new TList(TType.String, Rows.Count));
              foreach (byte[] _iter136 in Rows)
              {
                oprot.WriteBinary(_iter136);
              }
              oprot.WriteListEnd();
            }
            oprot.WriteFieldEnd();
          }
          if (Columns != null && __isset.columns) {
            field.Name = "columns";
            field.Type = TType.List;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            {
              oprot.WriteListBegin(new TList(TType.String, Columns.Count));
              foreach (byte[] _iter137 in Columns)
              {
                oprot.WriteBinary(_iter137);
              }
              oprot.WriteListEnd();
            }
            oprot.WriteFieldEnd();
          }
          if (Attributes != null && __isset.attributes) {
            field.Name = "attributes";
            field.Type = TType.Map;
            field.ID = 4;
            oprot.WriteFieldBegin(field);
            {
              oprot.WriteMapBegin(new TMap(TType.String, TType.String, Attributes.Count));
              foreach (byte[] _iter138 in Attributes.Keys)
              {
                oprot.WriteBinary(_iter138);
                oprot.WriteBinary(Attributes[_iter138]);
              }
              oprot.WriteMapEnd();
            }
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getRowsWithColumns_args(");
        bool __first = true;
        if (TableName != null && __isset.tableName) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("TableName: ");
          __sb.Append(TableName);
        }
        if (Rows != null && __isset.rows) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Rows: ");
          __sb.Append(Rows);
        }
        if (Columns != null && __isset.columns) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Columns: ");
          __sb.Append(Columns);
        }
        if (Attributes != null && __isset.attributes) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Attributes: ");
          __sb.Append(Attributes);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getRowsWithColumns_result : TBase
    {
      private List<TRowResult> _success;
      private IOError _io;

      public List<TRowResult> Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public IOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool io;
      }

      public getRowsWithColumns_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.List) {
                  {
                    Success = new List<TRowResult>();
                    TList _list139 = iprot.ReadListBegin();
                    for( int _i140 = 0; _i140 < _list139.Count; ++_i140)
                    {
                      TRowResult _elem141;
                      _elem141 = new TRowResult();
                      _elem141.Read(iprot);
                      Success.Add(_elem141);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new IOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getRowsWithColumns_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.List;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              {
                oprot.WriteListBegin(new TList(TType.Struct, Success.Count));
                foreach (TRowResult _iter142 in Success)
                {
                  _iter142.Write(oprot);
                }
                oprot.WriteListEnd();
              }
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getRowsWithColumns_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getRowsTs_args : TBase
    {
      private byte[] _tableName;
      private List<byte[]> _rows;
      private long _timestamp;
      private Dictionary<byte[], byte[]> _attributes;

      /// <summary>
      /// name of the table
      /// </summary>
      public byte[] TableName
      {
        get
        {
          return _tableName;
        }
        set
        {
          __isset.tableName = true;
          this._tableName = value;
        }
      }

      /// <summary>
      /// row keys
      /// </summary>
      public List<byte[]> Rows
      {
        get
        {
          return _rows;
        }
        set
        {
          __isset.rows = true;
          this._rows = value;
        }
      }

      /// <summary>
      /// timestamp
      /// </summary>
      public long Timestamp
      {
        get
        {
          return _timestamp;
        }
        set
        {
          __isset.timestamp = true;
          this._timestamp = value;
        }
      }

      /// <summary>
      /// Get attributes
      /// </summary>
      public Dictionary<byte[], byte[]> Attributes
      {
        get
        {
          return _attributes;
        }
        set
        {
          __isset.attributes = true;
          this._attributes = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool tableName;
        public bool rows;
        public bool timestamp;
        public bool attributes;
      }

      public getRowsTs_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  TableName = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.List) {
                  {
                    Rows = new List<byte[]>();
                    TList _list143 = iprot.ReadListBegin();
                    for( int _i144 = 0; _i144 < _list143.Count; ++_i144)
                    {
                      byte[] _elem145;
                      _elem145 = iprot.ReadBinary();
                      Rows.Add(_elem145);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.I64) {
                  Timestamp = iprot.ReadI64();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 4:
                if (field.Type == TType.Map) {
                  {
                    Attributes = new Dictionary<byte[], byte[]>();
                    TMap _map146 = iprot.ReadMapBegin();
                    for( int _i147 = 0; _i147 < _map146.Count; ++_i147)
                    {
                      byte[] _key148;
                      byte[] _val149;
                      _key148 = iprot.ReadBinary();
                      _val149 = iprot.ReadBinary();
                      Attributes[_key148] = _val149;
                    }
                    iprot.ReadMapEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getRowsTs_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (TableName != null && __isset.tableName) {
            field.Name = "tableName";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(TableName);
            oprot.WriteFieldEnd();
          }
          if (Rows != null && __isset.rows) {
            field.Name = "rows";
            field.Type = TType.List;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            {
              oprot.WriteListBegin(new TList(TType.String, Rows.Count));
              foreach (byte[] _iter150 in Rows)
              {
                oprot.WriteBinary(_iter150);
              }
              oprot.WriteListEnd();
            }
            oprot.WriteFieldEnd();
          }
          if (__isset.timestamp) {
            field.Name = "timestamp";
            field.Type = TType.I64;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            oprot.WriteI64(Timestamp);
            oprot.WriteFieldEnd();
          }
          if (Attributes != null && __isset.attributes) {
            field.Name = "attributes";
            field.Type = TType.Map;
            field.ID = 4;
            oprot.WriteFieldBegin(field);
            {
              oprot.WriteMapBegin(new TMap(TType.String, TType.String, Attributes.Count));
              foreach (byte[] _iter151 in Attributes.Keys)
              {
                oprot.WriteBinary(_iter151);
                oprot.WriteBinary(Attributes[_iter151]);
              }
              oprot.WriteMapEnd();
            }
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getRowsTs_args(");
        bool __first = true;
        if (TableName != null && __isset.tableName) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("TableName: ");
          __sb.Append(TableName);
        }
        if (Rows != null && __isset.rows) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Rows: ");
          __sb.Append(Rows);
        }
        if (__isset.timestamp) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Timestamp: ");
          __sb.Append(Timestamp);
        }
        if (Attributes != null && __isset.attributes) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Attributes: ");
          __sb.Append(Attributes);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getRowsTs_result : TBase
    {
      private List<TRowResult> _success;
      private IOError _io;

      public List<TRowResult> Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public IOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool io;
      }

      public getRowsTs_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.List) {
                  {
                    Success = new List<TRowResult>();
                    TList _list152 = iprot.ReadListBegin();
                    for( int _i153 = 0; _i153 < _list152.Count; ++_i153)
                    {
                      TRowResult _elem154;
                      _elem154 = new TRowResult();
                      _elem154.Read(iprot);
                      Success.Add(_elem154);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new IOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getRowsTs_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.List;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              {
                oprot.WriteListBegin(new TList(TType.Struct, Success.Count));
                foreach (TRowResult _iter155 in Success)
                {
                  _iter155.Write(oprot);
                }
                oprot.WriteListEnd();
              }
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getRowsTs_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getRowsWithColumnsTs_args : TBase
    {
      private byte[] _tableName;
      private List<byte[]> _rows;
      private List<byte[]> _columns;
      private long _timestamp;
      private Dictionary<byte[], byte[]> _attributes;

      /// <summary>
      /// name of table
      /// </summary>
      public byte[] TableName
      {
        get
        {
          return _tableName;
        }
        set
        {
          __isset.tableName = true;
          this._tableName = value;
        }
      }

      /// <summary>
      /// row keys
      /// </summary>
      public List<byte[]> Rows
      {
        get
        {
          return _rows;
        }
        set
        {
          __isset.rows = true;
          this._rows = value;
        }
      }

      /// <summary>
      /// List of columns to return, null for all columns
      /// </summary>
      public List<byte[]> Columns
      {
        get
        {
          return _columns;
        }
        set
        {
          __isset.columns = true;
          this._columns = value;
        }
      }

      public long Timestamp
      {
        get
        {
          return _timestamp;
        }
        set
        {
          __isset.timestamp = true;
          this._timestamp = value;
        }
      }

      /// <summary>
      /// Get attributes
      /// </summary>
      public Dictionary<byte[], byte[]> Attributes
      {
        get
        {
          return _attributes;
        }
        set
        {
          __isset.attributes = true;
          this._attributes = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool tableName;
        public bool rows;
        public bool columns;
        public bool timestamp;
        public bool attributes;
      }

      public getRowsWithColumnsTs_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  TableName = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.List) {
                  {
                    Rows = new List<byte[]>();
                    TList _list156 = iprot.ReadListBegin();
                    for( int _i157 = 0; _i157 < _list156.Count; ++_i157)
                    {
                      byte[] _elem158;
                      _elem158 = iprot.ReadBinary();
                      Rows.Add(_elem158);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.List) {
                  {
                    Columns = new List<byte[]>();
                    TList _list159 = iprot.ReadListBegin();
                    for( int _i160 = 0; _i160 < _list159.Count; ++_i160)
                    {
                      byte[] _elem161;
                      _elem161 = iprot.ReadBinary();
                      Columns.Add(_elem161);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 4:
                if (field.Type == TType.I64) {
                  Timestamp = iprot.ReadI64();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 5:
                if (field.Type == TType.Map) {
                  {
                    Attributes = new Dictionary<byte[], byte[]>();
                    TMap _map162 = iprot.ReadMapBegin();
                    for( int _i163 = 0; _i163 < _map162.Count; ++_i163)
                    {
                      byte[] _key164;
                      byte[] _val165;
                      _key164 = iprot.ReadBinary();
                      _val165 = iprot.ReadBinary();
                      Attributes[_key164] = _val165;
                    }
                    iprot.ReadMapEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getRowsWithColumnsTs_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (TableName != null && __isset.tableName) {
            field.Name = "tableName";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(TableName);
            oprot.WriteFieldEnd();
          }
          if (Rows != null && __isset.rows) {
            field.Name = "rows";
            field.Type = TType.List;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            {
              oprot.WriteListBegin(new TList(TType.String, Rows.Count));
              foreach (byte[] _iter166 in Rows)
              {
                oprot.WriteBinary(_iter166);
              }
              oprot.WriteListEnd();
            }
            oprot.WriteFieldEnd();
          }
          if (Columns != null && __isset.columns) {
            field.Name = "columns";
            field.Type = TType.List;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            {
              oprot.WriteListBegin(new TList(TType.String, Columns.Count));
              foreach (byte[] _iter167 in Columns)
              {
                oprot.WriteBinary(_iter167);
              }
              oprot.WriteListEnd();
            }
            oprot.WriteFieldEnd();
          }
          if (__isset.timestamp) {
            field.Name = "timestamp";
            field.Type = TType.I64;
            field.ID = 4;
            oprot.WriteFieldBegin(field);
            oprot.WriteI64(Timestamp);
            oprot.WriteFieldEnd();
          }
          if (Attributes != null && __isset.attributes) {
            field.Name = "attributes";
            field.Type = TType.Map;
            field.ID = 5;
            oprot.WriteFieldBegin(field);
            {
              oprot.WriteMapBegin(new TMap(TType.String, TType.String, Attributes.Count));
              foreach (byte[] _iter168 in Attributes.Keys)
              {
                oprot.WriteBinary(_iter168);
                oprot.WriteBinary(Attributes[_iter168]);
              }
              oprot.WriteMapEnd();
            }
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getRowsWithColumnsTs_args(");
        bool __first = true;
        if (TableName != null && __isset.tableName) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("TableName: ");
          __sb.Append(TableName);
        }
        if (Rows != null && __isset.rows) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Rows: ");
          __sb.Append(Rows);
        }
        if (Columns != null && __isset.columns) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Columns: ");
          __sb.Append(Columns);
        }
        if (__isset.timestamp) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Timestamp: ");
          __sb.Append(Timestamp);
        }
        if (Attributes != null && __isset.attributes) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Attributes: ");
          __sb.Append(Attributes);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getRowsWithColumnsTs_result : TBase
    {
      private List<TRowResult> _success;
      private IOError _io;

      public List<TRowResult> Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public IOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool io;
      }

      public getRowsWithColumnsTs_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.List) {
                  {
                    Success = new List<TRowResult>();
                    TList _list169 = iprot.ReadListBegin();
                    for( int _i170 = 0; _i170 < _list169.Count; ++_i170)
                    {
                      TRowResult _elem171;
                      _elem171 = new TRowResult();
                      _elem171.Read(iprot);
                      Success.Add(_elem171);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new IOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getRowsWithColumnsTs_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.List;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              {
                oprot.WriteListBegin(new TList(TType.Struct, Success.Count));
                foreach (TRowResult _iter172 in Success)
                {
                  _iter172.Write(oprot);
                }
                oprot.WriteListEnd();
              }
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getRowsWithColumnsTs_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class mutateRow_args : TBase
    {
      private byte[] _tableName;
      private byte[] _row;
      private List<Mutation> _mutations;
      private Dictionary<byte[], byte[]> _attributes;

      /// <summary>
      /// name of table
      /// </summary>
      public byte[] TableName
      {
        get
        {
          return _tableName;
        }
        set
        {
          __isset.tableName = true;
          this._tableName = value;
        }
      }

      /// <summary>
      /// row key
      /// </summary>
      public byte[] Row
      {
        get
        {
          return _row;
        }
        set
        {
          __isset.row = true;
          this._row = value;
        }
      }

      /// <summary>
      /// list of mutation commands
      /// </summary>
      public List<Mutation> Mutations
      {
        get
        {
          return _mutations;
        }
        set
        {
          __isset.mutations = true;
          this._mutations = value;
        }
      }

      /// <summary>
      /// Mutation attributes
      /// </summary>
      public Dictionary<byte[], byte[]> Attributes
      {
        get
        {
          return _attributes;
        }
        set
        {
          __isset.attributes = true;
          this._attributes = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool tableName;
        public bool row;
        public bool mutations;
        public bool attributes;
      }

      public mutateRow_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  TableName = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Row = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.List) {
                  {
                    Mutations = new List<Mutation>();
                    TList _list173 = iprot.ReadListBegin();
                    for( int _i174 = 0; _i174 < _list173.Count; ++_i174)
                    {
                      Mutation _elem175;
                      _elem175 = new Mutation();
                      _elem175.Read(iprot);
                      Mutations.Add(_elem175);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 4:
                if (field.Type == TType.Map) {
                  {
                    Attributes = new Dictionary<byte[], byte[]>();
                    TMap _map176 = iprot.ReadMapBegin();
                    for( int _i177 = 0; _i177 < _map176.Count; ++_i177)
                    {
                      byte[] _key178;
                      byte[] _val179;
                      _key178 = iprot.ReadBinary();
                      _val179 = iprot.ReadBinary();
                      Attributes[_key178] = _val179;
                    }
                    iprot.ReadMapEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("mutateRow_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (TableName != null && __isset.tableName) {
            field.Name = "tableName";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(TableName);
            oprot.WriteFieldEnd();
          }
          if (Row != null && __isset.row) {
            field.Name = "row";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(Row);
            oprot.WriteFieldEnd();
          }
          if (Mutations != null && __isset.mutations) {
            field.Name = "mutations";
            field.Type = TType.List;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            {
              oprot.WriteListBegin(new TList(TType.Struct, Mutations.Count));
              foreach (Mutation _iter180 in Mutations)
              {
                _iter180.Write(oprot);
              }
              oprot.WriteListEnd();
            }
            oprot.WriteFieldEnd();
          }
          if (Attributes != null && __isset.attributes) {
            field.Name = "attributes";
            field.Type = TType.Map;
            field.ID = 4;
            oprot.WriteFieldBegin(field);
            {
              oprot.WriteMapBegin(new TMap(TType.String, TType.String, Attributes.Count));
              foreach (byte[] _iter181 in Attributes.Keys)
              {
                oprot.WriteBinary(_iter181);
                oprot.WriteBinary(Attributes[_iter181]);
              }
              oprot.WriteMapEnd();
            }
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("mutateRow_args(");
        bool __first = true;
        if (TableName != null && __isset.tableName) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("TableName: ");
          __sb.Append(TableName);
        }
        if (Row != null && __isset.row) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Row: ");
          __sb.Append(Row);
        }
        if (Mutations != null && __isset.mutations) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Mutations: ");
          __sb.Append(Mutations);
        }
        if (Attributes != null && __isset.attributes) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Attributes: ");
          __sb.Append(Attributes);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class mutateRow_result : TBase
    {
      private IOError _io;
      private IllegalArgument _ia;

      public IOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }

      public IllegalArgument Ia
      {
        get
        {
          return _ia;
        }
        set
        {
          __isset.ia = true;
          this._ia = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool io;
        public bool ia;
      }

      public mutateRow_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new IOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Ia = new IllegalArgument();
                  Ia.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("mutateRow_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.ia) {
            if (Ia != null) {
              field.Name = "Ia";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              Ia.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("mutateRow_result(");
        bool __first = true;
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        if (Ia != null && __isset.ia) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ia: ");
          __sb.Append(Ia== null ? "<null>" : Ia.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class mutateRowTs_args : TBase
    {
      private byte[] _tableName;
      private byte[] _row;
      private List<Mutation> _mutations;
      private long _timestamp;
      private Dictionary<byte[], byte[]> _attributes;

      /// <summary>
      /// name of table
      /// </summary>
      public byte[] TableName
      {
        get
        {
          return _tableName;
        }
        set
        {
          __isset.tableName = true;
          this._tableName = value;
        }
      }

      /// <summary>
      /// row key
      /// </summary>
      public byte[] Row
      {
        get
        {
          return _row;
        }
        set
        {
          __isset.row = true;
          this._row = value;
        }
      }

      /// <summary>
      /// list of mutation commands
      /// </summary>
      public List<Mutation> Mutations
      {
        get
        {
          return _mutations;
        }
        set
        {
          __isset.mutations = true;
          this._mutations = value;
        }
      }

      /// <summary>
      /// timestamp
      /// </summary>
      public long Timestamp
      {
        get
        {
          return _timestamp;
        }
        set
        {
          __isset.timestamp = true;
          this._timestamp = value;
        }
      }

      /// <summary>
      /// Mutation attributes
      /// </summary>
      public Dictionary<byte[], byte[]> Attributes
      {
        get
        {
          return _attributes;
        }
        set
        {
          __isset.attributes = true;
          this._attributes = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool tableName;
        public bool row;
        public bool mutations;
        public bool timestamp;
        public bool attributes;
      }

      public mutateRowTs_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  TableName = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Row = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.List) {
                  {
                    Mutations = new List<Mutation>();
                    TList _list182 = iprot.ReadListBegin();
                    for( int _i183 = 0; _i183 < _list182.Count; ++_i183)
                    {
                      Mutation _elem184;
                      _elem184 = new Mutation();
                      _elem184.Read(iprot);
                      Mutations.Add(_elem184);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 4:
                if (field.Type == TType.I64) {
                  Timestamp = iprot.ReadI64();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 5:
                if (field.Type == TType.Map) {
                  {
                    Attributes = new Dictionary<byte[], byte[]>();
                    TMap _map185 = iprot.ReadMapBegin();
                    for( int _i186 = 0; _i186 < _map185.Count; ++_i186)
                    {
                      byte[] _key187;
                      byte[] _val188;
                      _key187 = iprot.ReadBinary();
                      _val188 = iprot.ReadBinary();
                      Attributes[_key187] = _val188;
                    }
                    iprot.ReadMapEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("mutateRowTs_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (TableName != null && __isset.tableName) {
            field.Name = "tableName";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(TableName);
            oprot.WriteFieldEnd();
          }
          if (Row != null && __isset.row) {
            field.Name = "row";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(Row);
            oprot.WriteFieldEnd();
          }
          if (Mutations != null && __isset.mutations) {
            field.Name = "mutations";
            field.Type = TType.List;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            {
              oprot.WriteListBegin(new TList(TType.Struct, Mutations.Count));
              foreach (Mutation _iter189 in Mutations)
              {
                _iter189.Write(oprot);
              }
              oprot.WriteListEnd();
            }
            oprot.WriteFieldEnd();
          }
          if (__isset.timestamp) {
            field.Name = "timestamp";
            field.Type = TType.I64;
            field.ID = 4;
            oprot.WriteFieldBegin(field);
            oprot.WriteI64(Timestamp);
            oprot.WriteFieldEnd();
          }
          if (Attributes != null && __isset.attributes) {
            field.Name = "attributes";
            field.Type = TType.Map;
            field.ID = 5;
            oprot.WriteFieldBegin(field);
            {
              oprot.WriteMapBegin(new TMap(TType.String, TType.String, Attributes.Count));
              foreach (byte[] _iter190 in Attributes.Keys)
              {
                oprot.WriteBinary(_iter190);
                oprot.WriteBinary(Attributes[_iter190]);
              }
              oprot.WriteMapEnd();
            }
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("mutateRowTs_args(");
        bool __first = true;
        if (TableName != null && __isset.tableName) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("TableName: ");
          __sb.Append(TableName);
        }
        if (Row != null && __isset.row) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Row: ");
          __sb.Append(Row);
        }
        if (Mutations != null && __isset.mutations) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Mutations: ");
          __sb.Append(Mutations);
        }
        if (__isset.timestamp) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Timestamp: ");
          __sb.Append(Timestamp);
        }
        if (Attributes != null && __isset.attributes) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Attributes: ");
          __sb.Append(Attributes);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class mutateRowTs_result : TBase
    {
      private IOError _io;
      private IllegalArgument _ia;

      public IOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }

      public IllegalArgument Ia
      {
        get
        {
          return _ia;
        }
        set
        {
          __isset.ia = true;
          this._ia = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool io;
        public bool ia;
      }

      public mutateRowTs_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new IOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Ia = new IllegalArgument();
                  Ia.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("mutateRowTs_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.ia) {
            if (Ia != null) {
              field.Name = "Ia";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              Ia.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("mutateRowTs_result(");
        bool __first = true;
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        if (Ia != null && __isset.ia) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ia: ");
          __sb.Append(Ia== null ? "<null>" : Ia.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class mutateRows_args : TBase
    {
      private byte[] _tableName;
      private List<BatchMutation> _rowBatches;
      private Dictionary<byte[], byte[]> _attributes;

      /// <summary>
      /// name of table
      /// </summary>
      public byte[] TableName
      {
        get
        {
          return _tableName;
        }
        set
        {
          __isset.tableName = true;
          this._tableName = value;
        }
      }

      /// <summary>
      /// list of row batches
      /// </summary>
      public List<BatchMutation> RowBatches
      {
        get
        {
          return _rowBatches;
        }
        set
        {
          __isset.rowBatches = true;
          this._rowBatches = value;
        }
      }

      /// <summary>
      /// Mutation attributes
      /// </summary>
      public Dictionary<byte[], byte[]> Attributes
      {
        get
        {
          return _attributes;
        }
        set
        {
          __isset.attributes = true;
          this._attributes = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool tableName;
        public bool rowBatches;
        public bool attributes;
      }

      public mutateRows_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  TableName = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.List) {
                  {
                    RowBatches = new List<BatchMutation>();
                    TList _list191 = iprot.ReadListBegin();
                    for( int _i192 = 0; _i192 < _list191.Count; ++_i192)
                    {
                      BatchMutation _elem193;
                      _elem193 = new BatchMutation();
                      _elem193.Read(iprot);
                      RowBatches.Add(_elem193);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Map) {
                  {
                    Attributes = new Dictionary<byte[], byte[]>();
                    TMap _map194 = iprot.ReadMapBegin();
                    for( int _i195 = 0; _i195 < _map194.Count; ++_i195)
                    {
                      byte[] _key196;
                      byte[] _val197;
                      _key196 = iprot.ReadBinary();
                      _val197 = iprot.ReadBinary();
                      Attributes[_key196] = _val197;
                    }
                    iprot.ReadMapEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("mutateRows_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (TableName != null && __isset.tableName) {
            field.Name = "tableName";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(TableName);
            oprot.WriteFieldEnd();
          }
          if (RowBatches != null && __isset.rowBatches) {
            field.Name = "rowBatches";
            field.Type = TType.List;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            {
              oprot.WriteListBegin(new TList(TType.Struct, RowBatches.Count));
              foreach (BatchMutation _iter198 in RowBatches)
              {
                _iter198.Write(oprot);
              }
              oprot.WriteListEnd();
            }
            oprot.WriteFieldEnd();
          }
          if (Attributes != null && __isset.attributes) {
            field.Name = "attributes";
            field.Type = TType.Map;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            {
              oprot.WriteMapBegin(new TMap(TType.String, TType.String, Attributes.Count));
              foreach (byte[] _iter199 in Attributes.Keys)
              {
                oprot.WriteBinary(_iter199);
                oprot.WriteBinary(Attributes[_iter199]);
              }
              oprot.WriteMapEnd();
            }
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("mutateRows_args(");
        bool __first = true;
        if (TableName != null && __isset.tableName) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("TableName: ");
          __sb.Append(TableName);
        }
        if (RowBatches != null && __isset.rowBatches) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("RowBatches: ");
          __sb.Append(RowBatches);
        }
        if (Attributes != null && __isset.attributes) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Attributes: ");
          __sb.Append(Attributes);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class mutateRows_result : TBase
    {
      private IOError _io;
      private IllegalArgument _ia;

      public IOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }

      public IllegalArgument Ia
      {
        get
        {
          return _ia;
        }
        set
        {
          __isset.ia = true;
          this._ia = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool io;
        public bool ia;
      }

      public mutateRows_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new IOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Ia = new IllegalArgument();
                  Ia.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("mutateRows_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.ia) {
            if (Ia != null) {
              field.Name = "Ia";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              Ia.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("mutateRows_result(");
        bool __first = true;
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        if (Ia != null && __isset.ia) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ia: ");
          __sb.Append(Ia== null ? "<null>" : Ia.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class mutateRowsTs_args : TBase
    {
      private byte[] _tableName;
      private List<BatchMutation> _rowBatches;
      private long _timestamp;
      private Dictionary<byte[], byte[]> _attributes;

      /// <summary>
      /// name of table
      /// </summary>
      public byte[] TableName
      {
        get
        {
          return _tableName;
        }
        set
        {
          __isset.tableName = true;
          this._tableName = value;
        }
      }

      /// <summary>
      /// list of row batches
      /// </summary>
      public List<BatchMutation> RowBatches
      {
        get
        {
          return _rowBatches;
        }
        set
        {
          __isset.rowBatches = true;
          this._rowBatches = value;
        }
      }

      /// <summary>
      /// timestamp
      /// </summary>
      public long Timestamp
      {
        get
        {
          return _timestamp;
        }
        set
        {
          __isset.timestamp = true;
          this._timestamp = value;
        }
      }

      /// <summary>
      /// Mutation attributes
      /// </summary>
      public Dictionary<byte[], byte[]> Attributes
      {
        get
        {
          return _attributes;
        }
        set
        {
          __isset.attributes = true;
          this._attributes = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool tableName;
        public bool rowBatches;
        public bool timestamp;
        public bool attributes;
      }

      public mutateRowsTs_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  TableName = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.List) {
                  {
                    RowBatches = new List<BatchMutation>();
                    TList _list200 = iprot.ReadListBegin();
                    for( int _i201 = 0; _i201 < _list200.Count; ++_i201)
                    {
                      BatchMutation _elem202;
                      _elem202 = new BatchMutation();
                      _elem202.Read(iprot);
                      RowBatches.Add(_elem202);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.I64) {
                  Timestamp = iprot.ReadI64();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 4:
                if (field.Type == TType.Map) {
                  {
                    Attributes = new Dictionary<byte[], byte[]>();
                    TMap _map203 = iprot.ReadMapBegin();
                    for( int _i204 = 0; _i204 < _map203.Count; ++_i204)
                    {
                      byte[] _key205;
                      byte[] _val206;
                      _key205 = iprot.ReadBinary();
                      _val206 = iprot.ReadBinary();
                      Attributes[_key205] = _val206;
                    }
                    iprot.ReadMapEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("mutateRowsTs_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (TableName != null && __isset.tableName) {
            field.Name = "tableName";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(TableName);
            oprot.WriteFieldEnd();
          }
          if (RowBatches != null && __isset.rowBatches) {
            field.Name = "rowBatches";
            field.Type = TType.List;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            {
              oprot.WriteListBegin(new TList(TType.Struct, RowBatches.Count));
              foreach (BatchMutation _iter207 in RowBatches)
              {
                _iter207.Write(oprot);
              }
              oprot.WriteListEnd();
            }
            oprot.WriteFieldEnd();
          }
          if (__isset.timestamp) {
            field.Name = "timestamp";
            field.Type = TType.I64;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            oprot.WriteI64(Timestamp);
            oprot.WriteFieldEnd();
          }
          if (Attributes != null && __isset.attributes) {
            field.Name = "attributes";
            field.Type = TType.Map;
            field.ID = 4;
            oprot.WriteFieldBegin(field);
            {
              oprot.WriteMapBegin(new TMap(TType.String, TType.String, Attributes.Count));
              foreach (byte[] _iter208 in Attributes.Keys)
              {
                oprot.WriteBinary(_iter208);
                oprot.WriteBinary(Attributes[_iter208]);
              }
              oprot.WriteMapEnd();
            }
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("mutateRowsTs_args(");
        bool __first = true;
        if (TableName != null && __isset.tableName) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("TableName: ");
          __sb.Append(TableName);
        }
        if (RowBatches != null && __isset.rowBatches) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("RowBatches: ");
          __sb.Append(RowBatches);
        }
        if (__isset.timestamp) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Timestamp: ");
          __sb.Append(Timestamp);
        }
        if (Attributes != null && __isset.attributes) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Attributes: ");
          __sb.Append(Attributes);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class mutateRowsTs_result : TBase
    {
      private IOError _io;
      private IllegalArgument _ia;

      public IOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }

      public IllegalArgument Ia
      {
        get
        {
          return _ia;
        }
        set
        {
          __isset.ia = true;
          this._ia = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool io;
        public bool ia;
      }

      public mutateRowsTs_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new IOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Ia = new IllegalArgument();
                  Ia.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("mutateRowsTs_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.ia) {
            if (Ia != null) {
              field.Name = "Ia";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              Ia.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("mutateRowsTs_result(");
        bool __first = true;
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        if (Ia != null && __isset.ia) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ia: ");
          __sb.Append(Ia== null ? "<null>" : Ia.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class atomicIncrement_args : TBase
    {
      private byte[] _tableName;
      private byte[] _row;
      private byte[] _column;
      private long _value;

      /// <summary>
      /// name of table
      /// </summary>
      public byte[] TableName
      {
        get
        {
          return _tableName;
        }
        set
        {
          __isset.tableName = true;
          this._tableName = value;
        }
      }

      /// <summary>
      /// row to increment
      /// </summary>
      public byte[] Row
      {
        get
        {
          return _row;
        }
        set
        {
          __isset.row = true;
          this._row = value;
        }
      }

      /// <summary>
      /// name of column
      /// </summary>
      public byte[] Column
      {
        get
        {
          return _column;
        }
        set
        {
          __isset.column = true;
          this._column = value;
        }
      }

      /// <summary>
      /// amount to increment by
      /// </summary>
      public long Value
      {
        get
        {
          return _value;
        }
        set
        {
          __isset.@value = true;
          this._value = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool tableName;
        public bool row;
        public bool column;
        public bool @value;
      }

      public atomicIncrement_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  TableName = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Row = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.String) {
                  Column = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 4:
                if (field.Type == TType.I64) {
                  Value = iprot.ReadI64();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("atomicIncrement_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (TableName != null && __isset.tableName) {
            field.Name = "tableName";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(TableName);
            oprot.WriteFieldEnd();
          }
          if (Row != null && __isset.row) {
            field.Name = "row";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(Row);
            oprot.WriteFieldEnd();
          }
          if (Column != null && __isset.column) {
            field.Name = "column";
            field.Type = TType.String;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(Column);
            oprot.WriteFieldEnd();
          }
          if (__isset.@value) {
            field.Name = "value";
            field.Type = TType.I64;
            field.ID = 4;
            oprot.WriteFieldBegin(field);
            oprot.WriteI64(Value);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("atomicIncrement_args(");
        bool __first = true;
        if (TableName != null && __isset.tableName) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("TableName: ");
          __sb.Append(TableName);
        }
        if (Row != null && __isset.row) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Row: ");
          __sb.Append(Row);
        }
        if (Column != null && __isset.column) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Column: ");
          __sb.Append(Column);
        }
        if (__isset.@value) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Value: ");
          __sb.Append(Value);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class atomicIncrement_result : TBase
    {
      private long _success;
      private IOError _io;
      private IllegalArgument _ia;

      public long Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public IOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }

      public IllegalArgument Ia
      {
        get
        {
          return _ia;
        }
        set
        {
          __isset.ia = true;
          this._ia = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool io;
        public bool ia;
      }

      public atomicIncrement_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.I64) {
                  Success = iprot.ReadI64();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new IOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Ia = new IllegalArgument();
                  Ia.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("atomicIncrement_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            field.Name = "Success";
            field.Type = TType.I64;
            field.ID = 0;
            oprot.WriteFieldBegin(field);
            oprot.WriteI64(Success);
            oprot.WriteFieldEnd();
          } else if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.ia) {
            if (Ia != null) {
              field.Name = "Ia";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              Ia.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("atomicIncrement_result(");
        bool __first = true;
        if (__isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        if (Ia != null && __isset.ia) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ia: ");
          __sb.Append(Ia== null ? "<null>" : Ia.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class deleteAll_args : TBase
    {
      private byte[] _tableName;
      private byte[] _row;
      private byte[] _column;
      private Dictionary<byte[], byte[]> _attributes;

      /// <summary>
      /// name of table
      /// </summary>
      public byte[] TableName
      {
        get
        {
          return _tableName;
        }
        set
        {
          __isset.tableName = true;
          this._tableName = value;
        }
      }

      /// <summary>
      /// Row to update
      /// </summary>
      public byte[] Row
      {
        get
        {
          return _row;
        }
        set
        {
          __isset.row = true;
          this._row = value;
        }
      }

      /// <summary>
      /// name of column whose value is to be deleted
      /// </summary>
      public byte[] Column
      {
        get
        {
          return _column;
        }
        set
        {
          __isset.column = true;
          this._column = value;
        }
      }

      /// <summary>
      /// Delete attributes
      /// </summary>
      public Dictionary<byte[], byte[]> Attributes
      {
        get
        {
          return _attributes;
        }
        set
        {
          __isset.attributes = true;
          this._attributes = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool tableName;
        public bool row;
        public bool column;
        public bool attributes;
      }

      public deleteAll_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  TableName = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Row = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.String) {
                  Column = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 4:
                if (field.Type == TType.Map) {
                  {
                    Attributes = new Dictionary<byte[], byte[]>();
                    TMap _map209 = iprot.ReadMapBegin();
                    for( int _i210 = 0; _i210 < _map209.Count; ++_i210)
                    {
                      byte[] _key211;
                      byte[] _val212;
                      _key211 = iprot.ReadBinary();
                      _val212 = iprot.ReadBinary();
                      Attributes[_key211] = _val212;
                    }
                    iprot.ReadMapEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("deleteAll_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (TableName != null && __isset.tableName) {
            field.Name = "tableName";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(TableName);
            oprot.WriteFieldEnd();
          }
          if (Row != null && __isset.row) {
            field.Name = "row";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(Row);
            oprot.WriteFieldEnd();
          }
          if (Column != null && __isset.column) {
            field.Name = "column";
            field.Type = TType.String;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(Column);
            oprot.WriteFieldEnd();
          }
          if (Attributes != null && __isset.attributes) {
            field.Name = "attributes";
            field.Type = TType.Map;
            field.ID = 4;
            oprot.WriteFieldBegin(field);
            {
              oprot.WriteMapBegin(new TMap(TType.String, TType.String, Attributes.Count));
              foreach (byte[] _iter213 in Attributes.Keys)
              {
                oprot.WriteBinary(_iter213);
                oprot.WriteBinary(Attributes[_iter213]);
              }
              oprot.WriteMapEnd();
            }
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("deleteAll_args(");
        bool __first = true;
        if (TableName != null && __isset.tableName) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("TableName: ");
          __sb.Append(TableName);
        }
        if (Row != null && __isset.row) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Row: ");
          __sb.Append(Row);
        }
        if (Column != null && __isset.column) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Column: ");
          __sb.Append(Column);
        }
        if (Attributes != null && __isset.attributes) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Attributes: ");
          __sb.Append(Attributes);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class deleteAll_result : TBase
    {
      private IOError _io;

      public IOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool io;
      }

      public deleteAll_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new IOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("deleteAll_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("deleteAll_result(");
        bool __first = true;
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class deleteAllTs_args : TBase
    {
      private byte[] _tableName;
      private byte[] _row;
      private byte[] _column;
      private long _timestamp;
      private Dictionary<byte[], byte[]> _attributes;

      /// <summary>
      /// name of table
      /// </summary>
      public byte[] TableName
      {
        get
        {
          return _tableName;
        }
        set
        {
          __isset.tableName = true;
          this._tableName = value;
        }
      }

      /// <summary>
      /// Row to update
      /// </summary>
      public byte[] Row
      {
        get
        {
          return _row;
        }
        set
        {
          __isset.row = true;
          this._row = value;
        }
      }

      /// <summary>
      /// name of column whose value is to be deleted
      /// </summary>
      public byte[] Column
      {
        get
        {
          return _column;
        }
        set
        {
          __isset.column = true;
          this._column = value;
        }
      }

      /// <summary>
      /// timestamp
      /// </summary>
      public long Timestamp
      {
        get
        {
          return _timestamp;
        }
        set
        {
          __isset.timestamp = true;
          this._timestamp = value;
        }
      }

      /// <summary>
      /// Delete attributes
      /// </summary>
      public Dictionary<byte[], byte[]> Attributes
      {
        get
        {
          return _attributes;
        }
        set
        {
          __isset.attributes = true;
          this._attributes = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool tableName;
        public bool row;
        public bool column;
        public bool timestamp;
        public bool attributes;
      }

      public deleteAllTs_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  TableName = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Row = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.String) {
                  Column = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 4:
                if (field.Type == TType.I64) {
                  Timestamp = iprot.ReadI64();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 5:
                if (field.Type == TType.Map) {
                  {
                    Attributes = new Dictionary<byte[], byte[]>();
                    TMap _map214 = iprot.ReadMapBegin();
                    for( int _i215 = 0; _i215 < _map214.Count; ++_i215)
                    {
                      byte[] _key216;
                      byte[] _val217;
                      _key216 = iprot.ReadBinary();
                      _val217 = iprot.ReadBinary();
                      Attributes[_key216] = _val217;
                    }
                    iprot.ReadMapEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("deleteAllTs_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (TableName != null && __isset.tableName) {
            field.Name = "tableName";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(TableName);
            oprot.WriteFieldEnd();
          }
          if (Row != null && __isset.row) {
            field.Name = "row";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(Row);
            oprot.WriteFieldEnd();
          }
          if (Column != null && __isset.column) {
            field.Name = "column";
            field.Type = TType.String;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(Column);
            oprot.WriteFieldEnd();
          }
          if (__isset.timestamp) {
            field.Name = "timestamp";
            field.Type = TType.I64;
            field.ID = 4;
            oprot.WriteFieldBegin(field);
            oprot.WriteI64(Timestamp);
            oprot.WriteFieldEnd();
          }
          if (Attributes != null && __isset.attributes) {
            field.Name = "attributes";
            field.Type = TType.Map;
            field.ID = 5;
            oprot.WriteFieldBegin(field);
            {
              oprot.WriteMapBegin(new TMap(TType.String, TType.String, Attributes.Count));
              foreach (byte[] _iter218 in Attributes.Keys)
              {
                oprot.WriteBinary(_iter218);
                oprot.WriteBinary(Attributes[_iter218]);
              }
              oprot.WriteMapEnd();
            }
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("deleteAllTs_args(");
        bool __first = true;
        if (TableName != null && __isset.tableName) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("TableName: ");
          __sb.Append(TableName);
        }
        if (Row != null && __isset.row) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Row: ");
          __sb.Append(Row);
        }
        if (Column != null && __isset.column) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Column: ");
          __sb.Append(Column);
        }
        if (__isset.timestamp) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Timestamp: ");
          __sb.Append(Timestamp);
        }
        if (Attributes != null && __isset.attributes) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Attributes: ");
          __sb.Append(Attributes);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class deleteAllTs_result : TBase
    {
      private IOError _io;

      public IOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool io;
      }

      public deleteAllTs_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new IOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("deleteAllTs_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("deleteAllTs_result(");
        bool __first = true;
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class deleteAllRow_args : TBase
    {
      private byte[] _tableName;
      private byte[] _row;
      private Dictionary<byte[], byte[]> _attributes;

      /// <summary>
      /// name of table
      /// </summary>
      public byte[] TableName
      {
        get
        {
          return _tableName;
        }
        set
        {
          __isset.tableName = true;
          this._tableName = value;
        }
      }

      /// <summary>
      /// key of the row to be completely deleted.
      /// </summary>
      public byte[] Row
      {
        get
        {
          return _row;
        }
        set
        {
          __isset.row = true;
          this._row = value;
        }
      }

      /// <summary>
      /// Delete attributes
      /// </summary>
      public Dictionary<byte[], byte[]> Attributes
      {
        get
        {
          return _attributes;
        }
        set
        {
          __isset.attributes = true;
          this._attributes = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool tableName;
        public bool row;
        public bool attributes;
      }

      public deleteAllRow_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  TableName = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Row = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Map) {
                  {
                    Attributes = new Dictionary<byte[], byte[]>();
                    TMap _map219 = iprot.ReadMapBegin();
                    for( int _i220 = 0; _i220 < _map219.Count; ++_i220)
                    {
                      byte[] _key221;
                      byte[] _val222;
                      _key221 = iprot.ReadBinary();
                      _val222 = iprot.ReadBinary();
                      Attributes[_key221] = _val222;
                    }
                    iprot.ReadMapEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("deleteAllRow_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (TableName != null && __isset.tableName) {
            field.Name = "tableName";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(TableName);
            oprot.WriteFieldEnd();
          }
          if (Row != null && __isset.row) {
            field.Name = "row";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(Row);
            oprot.WriteFieldEnd();
          }
          if (Attributes != null && __isset.attributes) {
            field.Name = "attributes";
            field.Type = TType.Map;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            {
              oprot.WriteMapBegin(new TMap(TType.String, TType.String, Attributes.Count));
              foreach (byte[] _iter223 in Attributes.Keys)
              {
                oprot.WriteBinary(_iter223);
                oprot.WriteBinary(Attributes[_iter223]);
              }
              oprot.WriteMapEnd();
            }
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("deleteAllRow_args(");
        bool __first = true;
        if (TableName != null && __isset.tableName) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("TableName: ");
          __sb.Append(TableName);
        }
        if (Row != null && __isset.row) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Row: ");
          __sb.Append(Row);
        }
        if (Attributes != null && __isset.attributes) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Attributes: ");
          __sb.Append(Attributes);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class deleteAllRow_result : TBase
    {
      private IOError _io;

      public IOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool io;
      }

      public deleteAllRow_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new IOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("deleteAllRow_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("deleteAllRow_result(");
        bool __first = true;
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class increment_args : TBase
    {
      private TIncrement _increment;

      /// <summary>
      /// The single increment to apply
      /// </summary>
      public TIncrement Increment
      {
        get
        {
          return _increment;
        }
        set
        {
          __isset.increment = true;
          this._increment = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool increment;
      }

      public increment_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.Struct) {
                  Increment = new TIncrement();
                  Increment.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("increment_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (Increment != null && __isset.increment) {
            field.Name = "increment";
            field.Type = TType.Struct;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            Increment.Write(oprot);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("increment_args(");
        bool __first = true;
        if (Increment != null && __isset.increment) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Increment: ");
          __sb.Append(Increment== null ? "<null>" : Increment.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class increment_result : TBase
    {
      private IOError _io;

      public IOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool io;
      }

      public increment_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new IOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("increment_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("increment_result(");
        bool __first = true;
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class incrementRows_args : TBase
    {
      private List<TIncrement> _increments;

      /// <summary>
      /// The list of increments
      /// </summary>
      public List<TIncrement> Increments
      {
        get
        {
          return _increments;
        }
        set
        {
          __isset.increments = true;
          this._increments = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool increments;
      }

      public incrementRows_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.List) {
                  {
                    Increments = new List<TIncrement>();
                    TList _list224 = iprot.ReadListBegin();
                    for( int _i225 = 0; _i225 < _list224.Count; ++_i225)
                    {
                      TIncrement _elem226;
                      _elem226 = new TIncrement();
                      _elem226.Read(iprot);
                      Increments.Add(_elem226);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("incrementRows_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (Increments != null && __isset.increments) {
            field.Name = "increments";
            field.Type = TType.List;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            {
              oprot.WriteListBegin(new TList(TType.Struct, Increments.Count));
              foreach (TIncrement _iter227 in Increments)
              {
                _iter227.Write(oprot);
              }
              oprot.WriteListEnd();
            }
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("incrementRows_args(");
        bool __first = true;
        if (Increments != null && __isset.increments) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Increments: ");
          __sb.Append(Increments);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class incrementRows_result : TBase
    {
      private IOError _io;

      public IOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool io;
      }

      public incrementRows_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new IOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("incrementRows_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("incrementRows_result(");
        bool __first = true;
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class deleteAllRowTs_args : TBase
    {
      private byte[] _tableName;
      private byte[] _row;
      private long _timestamp;
      private Dictionary<byte[], byte[]> _attributes;

      /// <summary>
      /// name of table
      /// </summary>
      public byte[] TableName
      {
        get
        {
          return _tableName;
        }
        set
        {
          __isset.tableName = true;
          this._tableName = value;
        }
      }

      /// <summary>
      /// key of the row to be completely deleted.
      /// </summary>
      public byte[] Row
      {
        get
        {
          return _row;
        }
        set
        {
          __isset.row = true;
          this._row = value;
        }
      }

      /// <summary>
      /// timestamp
      /// </summary>
      public long Timestamp
      {
        get
        {
          return _timestamp;
        }
        set
        {
          __isset.timestamp = true;
          this._timestamp = value;
        }
      }

      /// <summary>
      /// Delete attributes
      /// </summary>
      public Dictionary<byte[], byte[]> Attributes
      {
        get
        {
          return _attributes;
        }
        set
        {
          __isset.attributes = true;
          this._attributes = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool tableName;
        public bool row;
        public bool timestamp;
        public bool attributes;
      }

      public deleteAllRowTs_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  TableName = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Row = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.I64) {
                  Timestamp = iprot.ReadI64();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 4:
                if (field.Type == TType.Map) {
                  {
                    Attributes = new Dictionary<byte[], byte[]>();
                    TMap _map228 = iprot.ReadMapBegin();
                    for( int _i229 = 0; _i229 < _map228.Count; ++_i229)
                    {
                      byte[] _key230;
                      byte[] _val231;
                      _key230 = iprot.ReadBinary();
                      _val231 = iprot.ReadBinary();
                      Attributes[_key230] = _val231;
                    }
                    iprot.ReadMapEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("deleteAllRowTs_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (TableName != null && __isset.tableName) {
            field.Name = "tableName";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(TableName);
            oprot.WriteFieldEnd();
          }
          if (Row != null && __isset.row) {
            field.Name = "row";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(Row);
            oprot.WriteFieldEnd();
          }
          if (__isset.timestamp) {
            field.Name = "timestamp";
            field.Type = TType.I64;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            oprot.WriteI64(Timestamp);
            oprot.WriteFieldEnd();
          }
          if (Attributes != null && __isset.attributes) {
            field.Name = "attributes";
            field.Type = TType.Map;
            field.ID = 4;
            oprot.WriteFieldBegin(field);
            {
              oprot.WriteMapBegin(new TMap(TType.String, TType.String, Attributes.Count));
              foreach (byte[] _iter232 in Attributes.Keys)
              {
                oprot.WriteBinary(_iter232);
                oprot.WriteBinary(Attributes[_iter232]);
              }
              oprot.WriteMapEnd();
            }
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("deleteAllRowTs_args(");
        bool __first = true;
        if (TableName != null && __isset.tableName) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("TableName: ");
          __sb.Append(TableName);
        }
        if (Row != null && __isset.row) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Row: ");
          __sb.Append(Row);
        }
        if (__isset.timestamp) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Timestamp: ");
          __sb.Append(Timestamp);
        }
        if (Attributes != null && __isset.attributes) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Attributes: ");
          __sb.Append(Attributes);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class deleteAllRowTs_result : TBase
    {
      private IOError _io;

      public IOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool io;
      }

      public deleteAllRowTs_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new IOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("deleteAllRowTs_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("deleteAllRowTs_result(");
        bool __first = true;
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class scannerOpenWithScan_args : TBase
    {
      private byte[] _tableName;
      private TScan _scan;
      private Dictionary<byte[], byte[]> _attributes;

      /// <summary>
      /// name of table
      /// </summary>
      public byte[] TableName
      {
        get
        {
          return _tableName;
        }
        set
        {
          __isset.tableName = true;
          this._tableName = value;
        }
      }

      /// <summary>
      /// Scan instance
      /// </summary>
      public TScan Scan
      {
        get
        {
          return _scan;
        }
        set
        {
          __isset.scan = true;
          this._scan = value;
        }
      }

      /// <summary>
      /// Scan attributes
      /// </summary>
      public Dictionary<byte[], byte[]> Attributes
      {
        get
        {
          return _attributes;
        }
        set
        {
          __isset.attributes = true;
          this._attributes = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool tableName;
        public bool scan;
        public bool attributes;
      }

      public scannerOpenWithScan_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  TableName = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Scan = new TScan();
                  Scan.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Map) {
                  {
                    Attributes = new Dictionary<byte[], byte[]>();
                    TMap _map233 = iprot.ReadMapBegin();
                    for( int _i234 = 0; _i234 < _map233.Count; ++_i234)
                    {
                      byte[] _key235;
                      byte[] _val236;
                      _key235 = iprot.ReadBinary();
                      _val236 = iprot.ReadBinary();
                      Attributes[_key235] = _val236;
                    }
                    iprot.ReadMapEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("scannerOpenWithScan_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (TableName != null && __isset.tableName) {
            field.Name = "tableName";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(TableName);
            oprot.WriteFieldEnd();
          }
          if (Scan != null && __isset.scan) {
            field.Name = "scan";
            field.Type = TType.Struct;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            Scan.Write(oprot);
            oprot.WriteFieldEnd();
          }
          if (Attributes != null && __isset.attributes) {
            field.Name = "attributes";
            field.Type = TType.Map;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            {
              oprot.WriteMapBegin(new TMap(TType.String, TType.String, Attributes.Count));
              foreach (byte[] _iter237 in Attributes.Keys)
              {
                oprot.WriteBinary(_iter237);
                oprot.WriteBinary(Attributes[_iter237]);
              }
              oprot.WriteMapEnd();
            }
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("scannerOpenWithScan_args(");
        bool __first = true;
        if (TableName != null && __isset.tableName) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("TableName: ");
          __sb.Append(TableName);
        }
        if (Scan != null && __isset.scan) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Scan: ");
          __sb.Append(Scan== null ? "<null>" : Scan.ToString());
        }
        if (Attributes != null && __isset.attributes) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Attributes: ");
          __sb.Append(Attributes);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class scannerOpenWithScan_result : TBase
    {
      private int _success;
      private IOError _io;

      public int Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public IOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool io;
      }

      public scannerOpenWithScan_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.I32) {
                  Success = iprot.ReadI32();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new IOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("scannerOpenWithScan_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            field.Name = "Success";
            field.Type = TType.I32;
            field.ID = 0;
            oprot.WriteFieldBegin(field);
            oprot.WriteI32(Success);
            oprot.WriteFieldEnd();
          } else if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("scannerOpenWithScan_result(");
        bool __first = true;
        if (__isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class scannerOpen_args : TBase
    {
      private byte[] _tableName;
      private byte[] _startRow;
      private List<byte[]> _columns;
      private Dictionary<byte[], byte[]> _attributes;

      /// <summary>
      /// name of table
      /// </summary>
      public byte[] TableName
      {
        get
        {
          return _tableName;
        }
        set
        {
          __isset.tableName = true;
          this._tableName = value;
        }
      }

      /// <summary>
      /// Starting row in table to scan.
      /// Send "" (empty string) to start at the first row.
      /// </summary>
      public byte[] StartRow
      {
        get
        {
          return _startRow;
        }
        set
        {
          __isset.startRow = true;
          this._startRow = value;
        }
      }

      /// <summary>
      /// columns to scan. If column name is a column family, all
      /// columns of the specified column family are returned. It's also possible
      /// to pass a regex in the column qualifier.
      /// </summary>
      public List<byte[]> Columns
      {
        get
        {
          return _columns;
        }
        set
        {
          __isset.columns = true;
          this._columns = value;
        }
      }

      /// <summary>
      /// Scan attributes
      /// </summary>
      public Dictionary<byte[], byte[]> Attributes
      {
        get
        {
          return _attributes;
        }
        set
        {
          __isset.attributes = true;
          this._attributes = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool tableName;
        public bool startRow;
        public bool columns;
        public bool attributes;
      }

      public scannerOpen_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  TableName = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  StartRow = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.List) {
                  {
                    Columns = new List<byte[]>();
                    TList _list238 = iprot.ReadListBegin();
                    for( int _i239 = 0; _i239 < _list238.Count; ++_i239)
                    {
                      byte[] _elem240;
                      _elem240 = iprot.ReadBinary();
                      Columns.Add(_elem240);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 4:
                if (field.Type == TType.Map) {
                  {
                    Attributes = new Dictionary<byte[], byte[]>();
                    TMap _map241 = iprot.ReadMapBegin();
                    for( int _i242 = 0; _i242 < _map241.Count; ++_i242)
                    {
                      byte[] _key243;
                      byte[] _val244;
                      _key243 = iprot.ReadBinary();
                      _val244 = iprot.ReadBinary();
                      Attributes[_key243] = _val244;
                    }
                    iprot.ReadMapEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("scannerOpen_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (TableName != null && __isset.tableName) {
            field.Name = "tableName";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(TableName);
            oprot.WriteFieldEnd();
          }
          if (StartRow != null && __isset.startRow) {
            field.Name = "startRow";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(StartRow);
            oprot.WriteFieldEnd();
          }
          if (Columns != null && __isset.columns) {
            field.Name = "columns";
            field.Type = TType.List;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            {
              oprot.WriteListBegin(new TList(TType.String, Columns.Count));
              foreach (byte[] _iter245 in Columns)
              {
                oprot.WriteBinary(_iter245);
              }
              oprot.WriteListEnd();
            }
            oprot.WriteFieldEnd();
          }
          if (Attributes != null && __isset.attributes) {
            field.Name = "attributes";
            field.Type = TType.Map;
            field.ID = 4;
            oprot.WriteFieldBegin(field);
            {
              oprot.WriteMapBegin(new TMap(TType.String, TType.String, Attributes.Count));
              foreach (byte[] _iter246 in Attributes.Keys)
              {
                oprot.WriteBinary(_iter246);
                oprot.WriteBinary(Attributes[_iter246]);
              }
              oprot.WriteMapEnd();
            }
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("scannerOpen_args(");
        bool __first = true;
        if (TableName != null && __isset.tableName) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("TableName: ");
          __sb.Append(TableName);
        }
        if (StartRow != null && __isset.startRow) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("StartRow: ");
          __sb.Append(StartRow);
        }
        if (Columns != null && __isset.columns) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Columns: ");
          __sb.Append(Columns);
        }
        if (Attributes != null && __isset.attributes) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Attributes: ");
          __sb.Append(Attributes);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class scannerOpen_result : TBase
    {
      private int _success;
      private IOError _io;

      public int Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public IOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool io;
      }

      public scannerOpen_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.I32) {
                  Success = iprot.ReadI32();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new IOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("scannerOpen_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            field.Name = "Success";
            field.Type = TType.I32;
            field.ID = 0;
            oprot.WriteFieldBegin(field);
            oprot.WriteI32(Success);
            oprot.WriteFieldEnd();
          } else if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("scannerOpen_result(");
        bool __first = true;
        if (__isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class scannerOpenWithStop_args : TBase
    {
      private byte[] _tableName;
      private byte[] _startRow;
      private byte[] _stopRow;
      private List<byte[]> _columns;
      private Dictionary<byte[], byte[]> _attributes;

      /// <summary>
      /// name of table
      /// </summary>
      public byte[] TableName
      {
        get
        {
          return _tableName;
        }
        set
        {
          __isset.tableName = true;
          this._tableName = value;
        }
      }

      /// <summary>
      /// Starting row in table to scan.
      /// Send "" (empty string) to start at the first row.
      /// </summary>
      public byte[] StartRow
      {
        get
        {
          return _startRow;
        }
        set
        {
          __isset.startRow = true;
          this._startRow = value;
        }
      }

      /// <summary>
      /// row to stop scanning on. This row is *not* included in the
      /// scanner's results
      /// </summary>
      public byte[] StopRow
      {
        get
        {
          return _stopRow;
        }
        set
        {
          __isset.stopRow = true;
          this._stopRow = value;
        }
      }

      /// <summary>
      /// columns to scan. If column name is a column family, all
      /// columns of the specified column family are returned. It's also possible
      /// to pass a regex in the column qualifier.
      /// </summary>
      public List<byte[]> Columns
      {
        get
        {
          return _columns;
        }
        set
        {
          __isset.columns = true;
          this._columns = value;
        }
      }

      /// <summary>
      /// Scan attributes
      /// </summary>
      public Dictionary<byte[], byte[]> Attributes
      {
        get
        {
          return _attributes;
        }
        set
        {
          __isset.attributes = true;
          this._attributes = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool tableName;
        public bool startRow;
        public bool stopRow;
        public bool columns;
        public bool attributes;
      }

      public scannerOpenWithStop_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  TableName = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  StartRow = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.String) {
                  StopRow = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 4:
                if (field.Type == TType.List) {
                  {
                    Columns = new List<byte[]>();
                    TList _list247 = iprot.ReadListBegin();
                    for( int _i248 = 0; _i248 < _list247.Count; ++_i248)
                    {
                      byte[] _elem249;
                      _elem249 = iprot.ReadBinary();
                      Columns.Add(_elem249);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 5:
                if (field.Type == TType.Map) {
                  {
                    Attributes = new Dictionary<byte[], byte[]>();
                    TMap _map250 = iprot.ReadMapBegin();
                    for( int _i251 = 0; _i251 < _map250.Count; ++_i251)
                    {
                      byte[] _key252;
                      byte[] _val253;
                      _key252 = iprot.ReadBinary();
                      _val253 = iprot.ReadBinary();
                      Attributes[_key252] = _val253;
                    }
                    iprot.ReadMapEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("scannerOpenWithStop_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (TableName != null && __isset.tableName) {
            field.Name = "tableName";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(TableName);
            oprot.WriteFieldEnd();
          }
          if (StartRow != null && __isset.startRow) {
            field.Name = "startRow";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(StartRow);
            oprot.WriteFieldEnd();
          }
          if (StopRow != null && __isset.stopRow) {
            field.Name = "stopRow";
            field.Type = TType.String;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(StopRow);
            oprot.WriteFieldEnd();
          }
          if (Columns != null && __isset.columns) {
            field.Name = "columns";
            field.Type = TType.List;
            field.ID = 4;
            oprot.WriteFieldBegin(field);
            {
              oprot.WriteListBegin(new TList(TType.String, Columns.Count));
              foreach (byte[] _iter254 in Columns)
              {
                oprot.WriteBinary(_iter254);
              }
              oprot.WriteListEnd();
            }
            oprot.WriteFieldEnd();
          }
          if (Attributes != null && __isset.attributes) {
            field.Name = "attributes";
            field.Type = TType.Map;
            field.ID = 5;
            oprot.WriteFieldBegin(field);
            {
              oprot.WriteMapBegin(new TMap(TType.String, TType.String, Attributes.Count));
              foreach (byte[] _iter255 in Attributes.Keys)
              {
                oprot.WriteBinary(_iter255);
                oprot.WriteBinary(Attributes[_iter255]);
              }
              oprot.WriteMapEnd();
            }
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("scannerOpenWithStop_args(");
        bool __first = true;
        if (TableName != null && __isset.tableName) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("TableName: ");
          __sb.Append(TableName);
        }
        if (StartRow != null && __isset.startRow) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("StartRow: ");
          __sb.Append(StartRow);
        }
        if (StopRow != null && __isset.stopRow) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("StopRow: ");
          __sb.Append(StopRow);
        }
        if (Columns != null && __isset.columns) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Columns: ");
          __sb.Append(Columns);
        }
        if (Attributes != null && __isset.attributes) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Attributes: ");
          __sb.Append(Attributes);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class scannerOpenWithStop_result : TBase
    {
      private int _success;
      private IOError _io;

      public int Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public IOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool io;
      }

      public scannerOpenWithStop_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.I32) {
                  Success = iprot.ReadI32();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new IOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("scannerOpenWithStop_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            field.Name = "Success";
            field.Type = TType.I32;
            field.ID = 0;
            oprot.WriteFieldBegin(field);
            oprot.WriteI32(Success);
            oprot.WriteFieldEnd();
          } else if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("scannerOpenWithStop_result(");
        bool __first = true;
        if (__isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class scannerOpenWithPrefix_args : TBase
    {
      private byte[] _tableName;
      private byte[] _startAndPrefix;
      private List<byte[]> _columns;
      private Dictionary<byte[], byte[]> _attributes;

      /// <summary>
      /// name of table
      /// </summary>
      public byte[] TableName
      {
        get
        {
          return _tableName;
        }
        set
        {
          __isset.tableName = true;
          this._tableName = value;
        }
      }

      /// <summary>
      /// the prefix (and thus start row) of the keys you want
      /// </summary>
      public byte[] StartAndPrefix
      {
        get
        {
          return _startAndPrefix;
        }
        set
        {
          __isset.startAndPrefix = true;
          this._startAndPrefix = value;
        }
      }

      /// <summary>
      /// the columns you want returned
      /// </summary>
      public List<byte[]> Columns
      {
        get
        {
          return _columns;
        }
        set
        {
          __isset.columns = true;
          this._columns = value;
        }
      }

      /// <summary>
      /// Scan attributes
      /// </summary>
      public Dictionary<byte[], byte[]> Attributes
      {
        get
        {
          return _attributes;
        }
        set
        {
          __isset.attributes = true;
          this._attributes = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool tableName;
        public bool startAndPrefix;
        public bool columns;
        public bool attributes;
      }

      public scannerOpenWithPrefix_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  TableName = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  StartAndPrefix = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.List) {
                  {
                    Columns = new List<byte[]>();
                    TList _list256 = iprot.ReadListBegin();
                    for( int _i257 = 0; _i257 < _list256.Count; ++_i257)
                    {
                      byte[] _elem258;
                      _elem258 = iprot.ReadBinary();
                      Columns.Add(_elem258);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 4:
                if (field.Type == TType.Map) {
                  {
                    Attributes = new Dictionary<byte[], byte[]>();
                    TMap _map259 = iprot.ReadMapBegin();
                    for( int _i260 = 0; _i260 < _map259.Count; ++_i260)
                    {
                      byte[] _key261;
                      byte[] _val262;
                      _key261 = iprot.ReadBinary();
                      _val262 = iprot.ReadBinary();
                      Attributes[_key261] = _val262;
                    }
                    iprot.ReadMapEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("scannerOpenWithPrefix_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (TableName != null && __isset.tableName) {
            field.Name = "tableName";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(TableName);
            oprot.WriteFieldEnd();
          }
          if (StartAndPrefix != null && __isset.startAndPrefix) {
            field.Name = "startAndPrefix";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(StartAndPrefix);
            oprot.WriteFieldEnd();
          }
          if (Columns != null && __isset.columns) {
            field.Name = "columns";
            field.Type = TType.List;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            {
              oprot.WriteListBegin(new TList(TType.String, Columns.Count));
              foreach (byte[] _iter263 in Columns)
              {
                oprot.WriteBinary(_iter263);
              }
              oprot.WriteListEnd();
            }
            oprot.WriteFieldEnd();
          }
          if (Attributes != null && __isset.attributes) {
            field.Name = "attributes";
            field.Type = TType.Map;
            field.ID = 4;
            oprot.WriteFieldBegin(field);
            {
              oprot.WriteMapBegin(new TMap(TType.String, TType.String, Attributes.Count));
              foreach (byte[] _iter264 in Attributes.Keys)
              {
                oprot.WriteBinary(_iter264);
                oprot.WriteBinary(Attributes[_iter264]);
              }
              oprot.WriteMapEnd();
            }
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("scannerOpenWithPrefix_args(");
        bool __first = true;
        if (TableName != null && __isset.tableName) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("TableName: ");
          __sb.Append(TableName);
        }
        if (StartAndPrefix != null && __isset.startAndPrefix) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("StartAndPrefix: ");
          __sb.Append(StartAndPrefix);
        }
        if (Columns != null && __isset.columns) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Columns: ");
          __sb.Append(Columns);
        }
        if (Attributes != null && __isset.attributes) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Attributes: ");
          __sb.Append(Attributes);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class scannerOpenWithPrefix_result : TBase
    {
      private int _success;
      private IOError _io;

      public int Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public IOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool io;
      }

      public scannerOpenWithPrefix_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.I32) {
                  Success = iprot.ReadI32();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new IOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("scannerOpenWithPrefix_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            field.Name = "Success";
            field.Type = TType.I32;
            field.ID = 0;
            oprot.WriteFieldBegin(field);
            oprot.WriteI32(Success);
            oprot.WriteFieldEnd();
          } else if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("scannerOpenWithPrefix_result(");
        bool __first = true;
        if (__isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class scannerOpenTs_args : TBase
    {
      private byte[] _tableName;
      private byte[] _startRow;
      private List<byte[]> _columns;
      private long _timestamp;
      private Dictionary<byte[], byte[]> _attributes;

      /// <summary>
      /// name of table
      /// </summary>
      public byte[] TableName
      {
        get
        {
          return _tableName;
        }
        set
        {
          __isset.tableName = true;
          this._tableName = value;
        }
      }

      /// <summary>
      /// Starting row in table to scan.
      /// Send "" (empty string) to start at the first row.
      /// </summary>
      public byte[] StartRow
      {
        get
        {
          return _startRow;
        }
        set
        {
          __isset.startRow = true;
          this._startRow = value;
        }
      }

      /// <summary>
      /// columns to scan. If column name is a column family, all
      /// columns of the specified column family are returned. It's also possible
      /// to pass a regex in the column qualifier.
      /// </summary>
      public List<byte[]> Columns
      {
        get
        {
          return _columns;
        }
        set
        {
          __isset.columns = true;
          this._columns = value;
        }
      }

      /// <summary>
      /// timestamp
      /// </summary>
      public long Timestamp
      {
        get
        {
          return _timestamp;
        }
        set
        {
          __isset.timestamp = true;
          this._timestamp = value;
        }
      }

      /// <summary>
      /// Scan attributes
      /// </summary>
      public Dictionary<byte[], byte[]> Attributes
      {
        get
        {
          return _attributes;
        }
        set
        {
          __isset.attributes = true;
          this._attributes = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool tableName;
        public bool startRow;
        public bool columns;
        public bool timestamp;
        public bool attributes;
      }

      public scannerOpenTs_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  TableName = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  StartRow = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.List) {
                  {
                    Columns = new List<byte[]>();
                    TList _list265 = iprot.ReadListBegin();
                    for( int _i266 = 0; _i266 < _list265.Count; ++_i266)
                    {
                      byte[] _elem267;
                      _elem267 = iprot.ReadBinary();
                      Columns.Add(_elem267);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 4:
                if (field.Type == TType.I64) {
                  Timestamp = iprot.ReadI64();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 5:
                if (field.Type == TType.Map) {
                  {
                    Attributes = new Dictionary<byte[], byte[]>();
                    TMap _map268 = iprot.ReadMapBegin();
                    for( int _i269 = 0; _i269 < _map268.Count; ++_i269)
                    {
                      byte[] _key270;
                      byte[] _val271;
                      _key270 = iprot.ReadBinary();
                      _val271 = iprot.ReadBinary();
                      Attributes[_key270] = _val271;
                    }
                    iprot.ReadMapEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("scannerOpenTs_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (TableName != null && __isset.tableName) {
            field.Name = "tableName";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(TableName);
            oprot.WriteFieldEnd();
          }
          if (StartRow != null && __isset.startRow) {
            field.Name = "startRow";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(StartRow);
            oprot.WriteFieldEnd();
          }
          if (Columns != null && __isset.columns) {
            field.Name = "columns";
            field.Type = TType.List;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            {
              oprot.WriteListBegin(new TList(TType.String, Columns.Count));
              foreach (byte[] _iter272 in Columns)
              {
                oprot.WriteBinary(_iter272);
              }
              oprot.WriteListEnd();
            }
            oprot.WriteFieldEnd();
          }
          if (__isset.timestamp) {
            field.Name = "timestamp";
            field.Type = TType.I64;
            field.ID = 4;
            oprot.WriteFieldBegin(field);
            oprot.WriteI64(Timestamp);
            oprot.WriteFieldEnd();
          }
          if (Attributes != null && __isset.attributes) {
            field.Name = "attributes";
            field.Type = TType.Map;
            field.ID = 5;
            oprot.WriteFieldBegin(field);
            {
              oprot.WriteMapBegin(new TMap(TType.String, TType.String, Attributes.Count));
              foreach (byte[] _iter273 in Attributes.Keys)
              {
                oprot.WriteBinary(_iter273);
                oprot.WriteBinary(Attributes[_iter273]);
              }
              oprot.WriteMapEnd();
            }
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("scannerOpenTs_args(");
        bool __first = true;
        if (TableName != null && __isset.tableName) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("TableName: ");
          __sb.Append(TableName);
        }
        if (StartRow != null && __isset.startRow) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("StartRow: ");
          __sb.Append(StartRow);
        }
        if (Columns != null && __isset.columns) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Columns: ");
          __sb.Append(Columns);
        }
        if (__isset.timestamp) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Timestamp: ");
          __sb.Append(Timestamp);
        }
        if (Attributes != null && __isset.attributes) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Attributes: ");
          __sb.Append(Attributes);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class scannerOpenTs_result : TBase
    {
      private int _success;
      private IOError _io;

      public int Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public IOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool io;
      }

      public scannerOpenTs_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.I32) {
                  Success = iprot.ReadI32();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new IOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("scannerOpenTs_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            field.Name = "Success";
            field.Type = TType.I32;
            field.ID = 0;
            oprot.WriteFieldBegin(field);
            oprot.WriteI32(Success);
            oprot.WriteFieldEnd();
          } else if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("scannerOpenTs_result(");
        bool __first = true;
        if (__isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class scannerOpenWithStopTs_args : TBase
    {
      private byte[] _tableName;
      private byte[] _startRow;
      private byte[] _stopRow;
      private List<byte[]> _columns;
      private long _timestamp;
      private Dictionary<byte[], byte[]> _attributes;

      /// <summary>
      /// name of table
      /// </summary>
      public byte[] TableName
      {
        get
        {
          return _tableName;
        }
        set
        {
          __isset.tableName = true;
          this._tableName = value;
        }
      }

      /// <summary>
      /// Starting row in table to scan.
      /// Send "" (empty string) to start at the first row.
      /// </summary>
      public byte[] StartRow
      {
        get
        {
          return _startRow;
        }
        set
        {
          __isset.startRow = true;
          this._startRow = value;
        }
      }

      /// <summary>
      /// row to stop scanning on. This row is *not* included in the
      /// scanner's results
      /// </summary>
      public byte[] StopRow
      {
        get
        {
          return _stopRow;
        }
        set
        {
          __isset.stopRow = true;
          this._stopRow = value;
        }
      }

      /// <summary>
      /// columns to scan. If column name is a column family, all
      /// columns of the specified column family are returned. It's also possible
      /// to pass a regex in the column qualifier.
      /// </summary>
      public List<byte[]> Columns
      {
        get
        {
          return _columns;
        }
        set
        {
          __isset.columns = true;
          this._columns = value;
        }
      }

      /// <summary>
      /// timestamp
      /// </summary>
      public long Timestamp
      {
        get
        {
          return _timestamp;
        }
        set
        {
          __isset.timestamp = true;
          this._timestamp = value;
        }
      }

      /// <summary>
      /// Scan attributes
      /// </summary>
      public Dictionary<byte[], byte[]> Attributes
      {
        get
        {
          return _attributes;
        }
        set
        {
          __isset.attributes = true;
          this._attributes = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool tableName;
        public bool startRow;
        public bool stopRow;
        public bool columns;
        public bool timestamp;
        public bool attributes;
      }

      public scannerOpenWithStopTs_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  TableName = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  StartRow = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.String) {
                  StopRow = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 4:
                if (field.Type == TType.List) {
                  {
                    Columns = new List<byte[]>();
                    TList _list274 = iprot.ReadListBegin();
                    for( int _i275 = 0; _i275 < _list274.Count; ++_i275)
                    {
                      byte[] _elem276;
                      _elem276 = iprot.ReadBinary();
                      Columns.Add(_elem276);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 5:
                if (field.Type == TType.I64) {
                  Timestamp = iprot.ReadI64();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 6:
                if (field.Type == TType.Map) {
                  {
                    Attributes = new Dictionary<byte[], byte[]>();
                    TMap _map277 = iprot.ReadMapBegin();
                    for( int _i278 = 0; _i278 < _map277.Count; ++_i278)
                    {
                      byte[] _key279;
                      byte[] _val280;
                      _key279 = iprot.ReadBinary();
                      _val280 = iprot.ReadBinary();
                      Attributes[_key279] = _val280;
                    }
                    iprot.ReadMapEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("scannerOpenWithStopTs_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (TableName != null && __isset.tableName) {
            field.Name = "tableName";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(TableName);
            oprot.WriteFieldEnd();
          }
          if (StartRow != null && __isset.startRow) {
            field.Name = "startRow";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(StartRow);
            oprot.WriteFieldEnd();
          }
          if (StopRow != null && __isset.stopRow) {
            field.Name = "stopRow";
            field.Type = TType.String;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(StopRow);
            oprot.WriteFieldEnd();
          }
          if (Columns != null && __isset.columns) {
            field.Name = "columns";
            field.Type = TType.List;
            field.ID = 4;
            oprot.WriteFieldBegin(field);
            {
              oprot.WriteListBegin(new TList(TType.String, Columns.Count));
              foreach (byte[] _iter281 in Columns)
              {
                oprot.WriteBinary(_iter281);
              }
              oprot.WriteListEnd();
            }
            oprot.WriteFieldEnd();
          }
          if (__isset.timestamp) {
            field.Name = "timestamp";
            field.Type = TType.I64;
            field.ID = 5;
            oprot.WriteFieldBegin(field);
            oprot.WriteI64(Timestamp);
            oprot.WriteFieldEnd();
          }
          if (Attributes != null && __isset.attributes) {
            field.Name = "attributes";
            field.Type = TType.Map;
            field.ID = 6;
            oprot.WriteFieldBegin(field);
            {
              oprot.WriteMapBegin(new TMap(TType.String, TType.String, Attributes.Count));
              foreach (byte[] _iter282 in Attributes.Keys)
              {
                oprot.WriteBinary(_iter282);
                oprot.WriteBinary(Attributes[_iter282]);
              }
              oprot.WriteMapEnd();
            }
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("scannerOpenWithStopTs_args(");
        bool __first = true;
        if (TableName != null && __isset.tableName) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("TableName: ");
          __sb.Append(TableName);
        }
        if (StartRow != null && __isset.startRow) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("StartRow: ");
          __sb.Append(StartRow);
        }
        if (StopRow != null && __isset.stopRow) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("StopRow: ");
          __sb.Append(StopRow);
        }
        if (Columns != null && __isset.columns) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Columns: ");
          __sb.Append(Columns);
        }
        if (__isset.timestamp) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Timestamp: ");
          __sb.Append(Timestamp);
        }
        if (Attributes != null && __isset.attributes) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Attributes: ");
          __sb.Append(Attributes);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class scannerOpenWithStopTs_result : TBase
    {
      private int _success;
      private IOError _io;

      public int Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public IOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool io;
      }

      public scannerOpenWithStopTs_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.I32) {
                  Success = iprot.ReadI32();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new IOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("scannerOpenWithStopTs_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            field.Name = "Success";
            field.Type = TType.I32;
            field.ID = 0;
            oprot.WriteFieldBegin(field);
            oprot.WriteI32(Success);
            oprot.WriteFieldEnd();
          } else if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("scannerOpenWithStopTs_result(");
        bool __first = true;
        if (__isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class scannerGet_args : TBase
    {
      private int _id;

      /// <summary>
      /// id of a scanner returned by scannerOpen
      /// </summary>
      public int Id
      {
        get
        {
          return _id;
        }
        set
        {
          __isset.id = true;
          this._id = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool id;
      }

      public scannerGet_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.I32) {
                  Id = iprot.ReadI32();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("scannerGet_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (__isset.id) {
            field.Name = "id";
            field.Type = TType.I32;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteI32(Id);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("scannerGet_args(");
        bool __first = true;
        if (__isset.id) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Id: ");
          __sb.Append(Id);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class scannerGet_result : TBase
    {
      private List<TRowResult> _success;
      private IOError _io;
      private IllegalArgument _ia;

      public List<TRowResult> Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public IOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }

      public IllegalArgument Ia
      {
        get
        {
          return _ia;
        }
        set
        {
          __isset.ia = true;
          this._ia = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool io;
        public bool ia;
      }

      public scannerGet_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.List) {
                  {
                    Success = new List<TRowResult>();
                    TList _list283 = iprot.ReadListBegin();
                    for( int _i284 = 0; _i284 < _list283.Count; ++_i284)
                    {
                      TRowResult _elem285;
                      _elem285 = new TRowResult();
                      _elem285.Read(iprot);
                      Success.Add(_elem285);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new IOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Ia = new IllegalArgument();
                  Ia.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("scannerGet_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.List;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              {
                oprot.WriteListBegin(new TList(TType.Struct, Success.Count));
                foreach (TRowResult _iter286 in Success)
                {
                  _iter286.Write(oprot);
                }
                oprot.WriteListEnd();
              }
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.ia) {
            if (Ia != null) {
              field.Name = "Ia";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              Ia.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("scannerGet_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        if (Ia != null && __isset.ia) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ia: ");
          __sb.Append(Ia== null ? "<null>" : Ia.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class scannerGetList_args : TBase
    {
      private int _id;
      private int _nbRows;

      /// <summary>
      /// id of a scanner returned by scannerOpen
      /// </summary>
      public int Id
      {
        get
        {
          return _id;
        }
        set
        {
          __isset.id = true;
          this._id = value;
        }
      }

      /// <summary>
      /// number of results to return
      /// </summary>
      public int NbRows
      {
        get
        {
          return _nbRows;
        }
        set
        {
          __isset.nbRows = true;
          this._nbRows = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool id;
        public bool nbRows;
      }

      public scannerGetList_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.I32) {
                  Id = iprot.ReadI32();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.I32) {
                  NbRows = iprot.ReadI32();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("scannerGetList_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (__isset.id) {
            field.Name = "id";
            field.Type = TType.I32;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteI32(Id);
            oprot.WriteFieldEnd();
          }
          if (__isset.nbRows) {
            field.Name = "nbRows";
            field.Type = TType.I32;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteI32(NbRows);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("scannerGetList_args(");
        bool __first = true;
        if (__isset.id) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Id: ");
          __sb.Append(Id);
        }
        if (__isset.nbRows) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NbRows: ");
          __sb.Append(NbRows);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class scannerGetList_result : TBase
    {
      private List<TRowResult> _success;
      private IOError _io;
      private IllegalArgument _ia;

      public List<TRowResult> Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public IOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }

      public IllegalArgument Ia
      {
        get
        {
          return _ia;
        }
        set
        {
          __isset.ia = true;
          this._ia = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool io;
        public bool ia;
      }

      public scannerGetList_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.List) {
                  {
                    Success = new List<TRowResult>();
                    TList _list287 = iprot.ReadListBegin();
                    for( int _i288 = 0; _i288 < _list287.Count; ++_i288)
                    {
                      TRowResult _elem289;
                      _elem289 = new TRowResult();
                      _elem289.Read(iprot);
                      Success.Add(_elem289);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new IOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Ia = new IllegalArgument();
                  Ia.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("scannerGetList_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.List;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              {
                oprot.WriteListBegin(new TList(TType.Struct, Success.Count));
                foreach (TRowResult _iter290 in Success)
                {
                  _iter290.Write(oprot);
                }
                oprot.WriteListEnd();
              }
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.ia) {
            if (Ia != null) {
              field.Name = "Ia";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              Ia.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("scannerGetList_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        if (Ia != null && __isset.ia) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ia: ");
          __sb.Append(Ia== null ? "<null>" : Ia.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class scannerClose_args : TBase
    {
      private int _id;

      /// <summary>
      /// id of a scanner returned by scannerOpen
      /// </summary>
      public int Id
      {
        get
        {
          return _id;
        }
        set
        {
          __isset.id = true;
          this._id = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool id;
      }

      public scannerClose_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.I32) {
                  Id = iprot.ReadI32();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("scannerClose_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (__isset.id) {
            field.Name = "id";
            field.Type = TType.I32;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteI32(Id);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("scannerClose_args(");
        bool __first = true;
        if (__isset.id) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Id: ");
          __sb.Append(Id);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class scannerClose_result : TBase
    {
      private IOError _io;
      private IllegalArgument _ia;

      public IOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }

      public IllegalArgument Ia
      {
        get
        {
          return _ia;
        }
        set
        {
          __isset.ia = true;
          this._ia = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool io;
        public bool ia;
      }

      public scannerClose_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new IOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Ia = new IllegalArgument();
                  Ia.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("scannerClose_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.ia) {
            if (Ia != null) {
              field.Name = "Ia";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              Ia.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("scannerClose_result(");
        bool __first = true;
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        if (Ia != null && __isset.ia) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ia: ");
          __sb.Append(Ia== null ? "<null>" : Ia.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getRowOrBefore_args : TBase
    {
      private byte[] _tableName;
      private byte[] _row;
      private byte[] _family;

      /// <summary>
      /// name of table
      /// </summary>
      public byte[] TableName
      {
        get
        {
          return _tableName;
        }
        set
        {
          __isset.tableName = true;
          this._tableName = value;
        }
      }

      /// <summary>
      /// row key
      /// </summary>
      public byte[] Row
      {
        get
        {
          return _row;
        }
        set
        {
          __isset.row = true;
          this._row = value;
        }
      }

      /// <summary>
      /// column name
      /// </summary>
      public byte[] Family
      {
        get
        {
          return _family;
        }
        set
        {
          __isset.family = true;
          this._family = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool tableName;
        public bool row;
        public bool family;
      }

      public getRowOrBefore_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  TableName = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Row = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.String) {
                  Family = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getRowOrBefore_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (TableName != null && __isset.tableName) {
            field.Name = "tableName";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(TableName);
            oprot.WriteFieldEnd();
          }
          if (Row != null && __isset.row) {
            field.Name = "row";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(Row);
            oprot.WriteFieldEnd();
          }
          if (Family != null && __isset.family) {
            field.Name = "family";
            field.Type = TType.String;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(Family);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getRowOrBefore_args(");
        bool __first = true;
        if (TableName != null && __isset.tableName) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("TableName: ");
          __sb.Append(TableName);
        }
        if (Row != null && __isset.row) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Row: ");
          __sb.Append(Row);
        }
        if (Family != null && __isset.family) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Family: ");
          __sb.Append(Family);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getRowOrBefore_result : TBase
    {
      private List<TCell> _success;
      private IOError _io;

      public List<TCell> Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public IOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool io;
      }

      public getRowOrBefore_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.List) {
                  {
                    Success = new List<TCell>();
                    TList _list291 = iprot.ReadListBegin();
                    for( int _i292 = 0; _i292 < _list291.Count; ++_i292)
                    {
                      TCell _elem293;
                      _elem293 = new TCell();
                      _elem293.Read(iprot);
                      Success.Add(_elem293);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new IOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getRowOrBefore_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.List;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              {
                oprot.WriteListBegin(new TList(TType.Struct, Success.Count));
                foreach (TCell _iter294 in Success)
                {
                  _iter294.Write(oprot);
                }
                oprot.WriteListEnd();
              }
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getRowOrBefore_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getRegionInfo_args : TBase
    {
      private byte[] _row;

      /// <summary>
      /// row key
      /// </summary>
      public byte[] Row
      {
        get
        {
          return _row;
        }
        set
        {
          __isset.row = true;
          this._row = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool row;
      }

      public getRegionInfo_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  Row = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getRegionInfo_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (Row != null && __isset.row) {
            field.Name = "row";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(Row);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getRegionInfo_args(");
        bool __first = true;
        if (Row != null && __isset.row) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Row: ");
          __sb.Append(Row);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getRegionInfo_result : TBase
    {
      private TRegionInfo _success;
      private IOError _io;

      public TRegionInfo Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public IOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool io;
      }

      public getRegionInfo_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Struct) {
                  Success = new TRegionInfo();
                  Success.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new IOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getRegionInfo_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Struct;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              Success.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getRegionInfo_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success== null ? "<null>" : Success.ToString());
        }
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class append_args : TBase
    {
      private TAppend _append;

      /// <summary>
      /// The single append operation to apply
      /// </summary>
      public TAppend Append
      {
        get
        {
          return _append;
        }
        set
        {
          __isset.append = true;
          this._append = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool append;
      }

      public append_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.Struct) {
                  Append = new TAppend();
                  Append.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("append_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (Append != null && __isset.append) {
            field.Name = "append";
            field.Type = TType.Struct;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            Append.Write(oprot);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("append_args(");
        bool __first = true;
        if (Append != null && __isset.append) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Append: ");
          __sb.Append(Append== null ? "<null>" : Append.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class append_result : TBase
    {
      private List<TCell> _success;
      private IOError _io;

      public List<TCell> Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public IOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool io;
      }

      public append_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.List) {
                  {
                    Success = new List<TCell>();
                    TList _list295 = iprot.ReadListBegin();
                    for( int _i296 = 0; _i296 < _list295.Count; ++_i296)
                    {
                      TCell _elem297;
                      _elem297 = new TCell();
                      _elem297.Read(iprot);
                      Success.Add(_elem297);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new IOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("append_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.List;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              {
                oprot.WriteListBegin(new TList(TType.Struct, Success.Count));
                foreach (TCell _iter298 in Success)
                {
                  _iter298.Write(oprot);
                }
                oprot.WriteListEnd();
              }
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("append_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class checkAndPut_args : TBase
    {
      private byte[] _tableName;
      private byte[] _row;
      private byte[] _column;
      private byte[] _value;
      private Mutation _mput;
      private Dictionary<byte[], byte[]> _attributes;

      /// <summary>
      /// name of table
      /// </summary>
      public byte[] TableName
      {
        get
        {
          return _tableName;
        }
        set
        {
          __isset.tableName = true;
          this._tableName = value;
        }
      }

      /// <summary>
      /// row key
      /// </summary>
      public byte[] Row
      {
        get
        {
          return _row;
        }
        set
        {
          __isset.row = true;
          this._row = value;
        }
      }

      /// <summary>
      /// column name
      /// </summary>
      public byte[] Column
      {
        get
        {
          return _column;
        }
        set
        {
          __isset.column = true;
          this._column = value;
        }
      }

      /// <summary>
      /// the expected value for the column parameter, if not
      /// provided the check is for the non-existence of the
      /// column in question
      /// </summary>
      public byte[] Value
      {
        get
        {
          return _value;
        }
        set
        {
          __isset.@value = true;
          this._value = value;
        }
      }

      /// <summary>
      /// mutation for the put
      /// </summary>
      public Mutation Mput
      {
        get
        {
          return _mput;
        }
        set
        {
          __isset.mput = true;
          this._mput = value;
        }
      }

      /// <summary>
      /// Mutation attributes
      /// </summary>
      public Dictionary<byte[], byte[]> Attributes
      {
        get
        {
          return _attributes;
        }
        set
        {
          __isset.attributes = true;
          this._attributes = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool tableName;
        public bool row;
        public bool column;
        public bool @value;
        public bool mput;
        public bool attributes;
      }

      public checkAndPut_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  TableName = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Row = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.String) {
                  Column = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 5:
                if (field.Type == TType.String) {
                  Value = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 6:
                if (field.Type == TType.Struct) {
                  Mput = new Mutation();
                  Mput.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 7:
                if (field.Type == TType.Map) {
                  {
                    Attributes = new Dictionary<byte[], byte[]>();
                    TMap _map299 = iprot.ReadMapBegin();
                    for( int _i300 = 0; _i300 < _map299.Count; ++_i300)
                    {
                      byte[] _key301;
                      byte[] _val302;
                      _key301 = iprot.ReadBinary();
                      _val302 = iprot.ReadBinary();
                      Attributes[_key301] = _val302;
                    }
                    iprot.ReadMapEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("checkAndPut_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (TableName != null && __isset.tableName) {
            field.Name = "tableName";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(TableName);
            oprot.WriteFieldEnd();
          }
          if (Row != null && __isset.row) {
            field.Name = "row";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(Row);
            oprot.WriteFieldEnd();
          }
          if (Column != null && __isset.column) {
            field.Name = "column";
            field.Type = TType.String;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(Column);
            oprot.WriteFieldEnd();
          }
          if (Value != null && __isset.@value) {
            field.Name = "value";
            field.Type = TType.String;
            field.ID = 5;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(Value);
            oprot.WriteFieldEnd();
          }
          if (Mput != null && __isset.mput) {
            field.Name = "mput";
            field.Type = TType.Struct;
            field.ID = 6;
            oprot.WriteFieldBegin(field);
            Mput.Write(oprot);
            oprot.WriteFieldEnd();
          }
          if (Attributes != null && __isset.attributes) {
            field.Name = "attributes";
            field.Type = TType.Map;
            field.ID = 7;
            oprot.WriteFieldBegin(field);
            {
              oprot.WriteMapBegin(new TMap(TType.String, TType.String, Attributes.Count));
              foreach (byte[] _iter303 in Attributes.Keys)
              {
                oprot.WriteBinary(_iter303);
                oprot.WriteBinary(Attributes[_iter303]);
              }
              oprot.WriteMapEnd();
            }
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("checkAndPut_args(");
        bool __first = true;
        if (TableName != null && __isset.tableName) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("TableName: ");
          __sb.Append(TableName);
        }
        if (Row != null && __isset.row) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Row: ");
          __sb.Append(Row);
        }
        if (Column != null && __isset.column) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Column: ");
          __sb.Append(Column);
        }
        if (Value != null && __isset.@value) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Value: ");
          __sb.Append(Value);
        }
        if (Mput != null && __isset.mput) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Mput: ");
          __sb.Append(Mput== null ? "<null>" : Mput.ToString());
        }
        if (Attributes != null && __isset.attributes) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Attributes: ");
          __sb.Append(Attributes);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class checkAndPut_result : TBase
    {
      private bool _success;
      private IOError _io;
      private IllegalArgument _ia;

      public bool Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public IOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }

      public IllegalArgument Ia
      {
        get
        {
          return _ia;
        }
        set
        {
          __isset.ia = true;
          this._ia = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool io;
        public bool ia;
      }

      public checkAndPut_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Bool) {
                  Success = iprot.ReadBool();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new IOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Ia = new IllegalArgument();
                  Ia.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("checkAndPut_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            field.Name = "Success";
            field.Type = TType.Bool;
            field.ID = 0;
            oprot.WriteFieldBegin(field);
            oprot.WriteBool(Success);
            oprot.WriteFieldEnd();
          } else if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.ia) {
            if (Ia != null) {
              field.Name = "Ia";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              Ia.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("checkAndPut_result(");
        bool __first = true;
        if (__isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        if (Ia != null && __isset.ia) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ia: ");
          __sb.Append(Ia== null ? "<null>" : Ia.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }

  }
}
